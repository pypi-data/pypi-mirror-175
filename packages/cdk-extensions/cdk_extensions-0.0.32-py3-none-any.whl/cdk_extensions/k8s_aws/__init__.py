'''
# K8S AWS Construct Library

Provides Kubernetes resources for integrating with AWS services.

## Secrets Manager

Enable synchronization of specific secret between Secrets Manager and Kubernetes:

```
declare const cluster: eks.Cluster;

const operator = new k8s_aws.ExternalSecretsOperator(this, 'external-secrets', {
    cluster: cluster
});
```

To tell the external secrets operator to synchronise a secret:

```
declase const operator: k8s_aws.ExternalSecretsOperator;
declare const secret: secretsmanager.Secret;

operator.registerSecretsManagerSecret('sychronized-secret', secret);
```

Give the secret a human friendly name in Kubernetes:

```
declase const operator: k8s_aws.ExternalSecretsOperator;
declare const secret: secretsmanager.Secret;

operator.registerSecretsManagerSecret('sychronized-secret', secret, {
    name: 'database-secret'
});
```

Only import specific JSON keys from a secret:

```
declase const operator: k8s_aws.ExternalSecretsOperator;
declare const secret: secretsmanager.Secret;

operator.registerSecretsManagerSecret('sychronized-secret', secret, {
    fields: [
        { kubernetesKey: 'username' },
        { kubernetesKey: 'password' },
    ]
});
```

Map secret fields that need to be different between Secrets Manager and Kubernetes.

```
declase const operator: k8s_aws.ExternalSecretsOperator;
declare const secret: secretsmanager.Secret;

operator.registerSecretsManagerSecret('sychronized-secret', secret, {
    fields: [
        {
            kubernetesKey: 'user',
            remoteKey: 'username',
        },
        {
            kubernetesKey: 'pass',
            remoteKey: 'password'
        },
    ]
});
```
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from .._jsii import *

import aws_cdk
import aws_cdk.aws_eks
import aws_cdk.aws_logs
import aws_cdk.aws_secretsmanager
import aws_cdk.aws_ssm
import constructs


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.AwsSecretStoreProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "service": "service",
        "name": "name",
        "namespace": "namespace",
    },
)
class AwsSecretStoreProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
        service: builtins.str,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration options for adding a new secret store resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: The EKS cluster where the secret store should be created.
        :param service: The name of the service provider backing the secret store.
        :param name: A human friendly name for the secret store.
        :param namespace: The Kubernetes namespace where the secret store should be created.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsSecretStoreProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
            "service": service,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS cluster where the secret store should be created.'''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    @builtins.property
    def service(self) -> builtins.str:
        '''The name of the service provider backing the secret store.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''A human friendly name for the secret store.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes namespace where the secret store should be created.'''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AwsSecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CloudWatchMonitoring(
    aws_cdk.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.CloudWatchMonitoring",
):
    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster: 
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudWatchMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudWatchMonitoringProps(
            cluster=cluster,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        return typing.cast(aws_cdk.aws_eks.ICluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> aws_cdk.aws_eks.KubernetesManifest:
        return typing.cast(aws_cdk.aws_eks.KubernetesManifest, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> aws_cdk.aws_eks.ServiceAccount:
        return typing.cast(aws_cdk.aws_eks.ServiceAccount, jsii.get(self, "serviceAccount"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.CloudWatchMonitoringProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
    },
)
class CloudWatchMonitoringProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
    ) -> None:
        '''
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudWatchMonitoringProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudWatchMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalDns(
    aws_cdk.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.ExternalDns",
):
    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster: 
        :param domain_filter: 
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalDns.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalDnsProps(
            cluster=cluster,
            domain_filter=domain_filter,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addDomainFilter")
    def add_domain_filter(self, domain: builtins.str) -> "ExternalDns":
        '''
        :param domain: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalDns.add_domain_filter)
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
        return typing.cast("ExternalDns", jsii.invoke(self, "addDomainFilter", [domain]))

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        return typing.cast(aws_cdk.aws_eks.ICluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="domainFilter")
    def domain_filter(self) -> typing.List[builtins.str]:
        return typing.cast(typing.List[builtins.str], jsii.get(self, "domainFilter"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> aws_cdk.aws_eks.HelmChart:
        return typing.cast(aws_cdk.aws_eks.HelmChart, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> aws_cdk.aws_eks.ServiceAccount:
        return typing.cast(aws_cdk.aws_eks.ServiceAccount, jsii.get(self, "serviceAccount"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.ExternalDnsProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "domain_filter": "domainFilter",
    },
)
class ExternalDnsProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Configuration for the Inbound Resolver resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: 
        :param domain_filter: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalDnsProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument domain_filter", value=domain_filter, expected_type=type_hints["domain_filter"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if domain_filter is not None:
            self._values["domain_filter"] = domain_filter

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    @builtins.property
    def domain_filter(self) -> typing.Optional[typing.List[builtins.str]]:
        result = self._values.get("domain_filter")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalDnsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalSecret(
    aws_cdk.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.ExternalSecret",
):
    '''Represents a Kubernetes secret that is being synchronized from an external provider.

    On a technical level, provides the configuration for how the external
    secrets operator service should manage the synchronization of the Kubernetes
    secret.
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        secret_store: "ISecretStore",
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        refresh_interval: typing.Optional[aws_cdk.Duration] = None,
        secrets: typing.Optional[typing.Sequence["ISecretReference"]] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the ExternalSecret class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
        :param cluster: The EKS cluster where the secret should be created.
        :param secret_store: The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
        :param name: The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
        :param namespace: The name where the synchronized secret should be created.
        :param refresh_interval: The frequency at which synchronization should occur.
        :param secrets: The secrets to synchronize into this Kubernetes secret. If multiple secrets are provided their fields will be merged.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecret.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalSecretProps(
            cluster=cluster,
            secret_store=secret_store,
            name=name,
            namespace=namespace,
            refresh_interval=refresh_interval,
            secrets=secrets,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSecret")
    def add_secret(self, secret: "ISecretReference") -> "ExternalSecret":
        '''Adds a provider secret reference to the synchronized Kubernetes secret.

        For external secrets that reference multiple provider secrets the keys of
        all provider secrets will be merged into the single Kubernetes secret.

        :param secret: The provider secret to reference.

        :return: The external secret resoiurce where the reference was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecret.add_secret)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        return typing.cast("ExternalSecret", jsii.invoke(self, "addSecret", [secret]))

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS cluster where the secret should be created.

        :group: Inputs
        '''
        return typing.cast(aws_cdk.aws_eks.ICluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="manifest")
    def manifest(self) -> aws_cdk.aws_eks.KubernetesManifest:
        '''The Kubernetes manifest defining the configuration of how to synchronize the Kubernetes secret from the provider secrets.

        :group: Resources
        '''
        return typing.cast(aws_cdk.aws_eks.KubernetesManifest, jsii.get(self, "manifest"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name to use for the Kubernetes secret resource when it is synchronized into the cluster.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="secretName")
    def secret_name(self) -> builtins.str:
        '''The name of the Kubernetes secret.'''
        return typing.cast(builtins.str, jsii.get(self, "secretName"))

    @builtins.property
    @jsii.member(jsii_name="secrets")
    def secrets(self) -> typing.List["ISecretReference"]:
        '''The collection of referenced provider secrets that are referenced in the Kubernetes secret.

        :group: Inputs
        '''
        return typing.cast(typing.List["ISecretReference"], jsii.get(self, "secrets"))

    @builtins.property
    @jsii.member(jsii_name="secretStore")
    def secret_store(self) -> "ISecretStore":
        '''The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.

        :group: Inputs
        '''
        return typing.cast("ISecretStore", jsii.get(self, "secretStore"))

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The name where the synchronized secret should be created.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "namespace"))

    @builtins.property
    @jsii.member(jsii_name="refreshInterval")
    def refresh_interval(self) -> typing.Optional[aws_cdk.Duration]:
        '''The frequency at which synchronization should occur.

        :group: Inputs
        '''
        return typing.cast(typing.Optional[aws_cdk.Duration], jsii.get(self, "refreshInterval"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.ExternalSecretOptions",
    jsii_struct_bases=[],
    name_mapping={"fields": "fields", "name": "name"},
)
class ExternalSecretOptions:
    def __init__(
        self,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param fields: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecretOptions.__init__)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fields is not None:
            self._values["fields"] = fields
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def fields(self) -> typing.Optional[typing.List["SecretFieldReference"]]:
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List["SecretFieldReference"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.ExternalSecretProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "secret_store": "secretStore",
        "name": "name",
        "namespace": "namespace",
        "refresh_interval": "refreshInterval",
        "secrets": "secrets",
    },
)
class ExternalSecretProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
        secret_store: "ISecretStore",
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        refresh_interval: typing.Optional[aws_cdk.Duration] = None,
        secrets: typing.Optional[typing.Sequence["ISecretReference"]] = None,
    ) -> None:
        '''Configuration for the ExternalSecret resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: The EKS cluster where the secret should be created.
        :param secret_store: The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
        :param name: The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
        :param namespace: The name where the synchronized secret should be created.
        :param refresh_interval: The frequency at which synchronization should occur.
        :param secrets: The secrets to synchronize into this Kubernetes secret. If multiple secrets are provided their fields will be merged.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecretProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument secret_store", value=secret_store, expected_type=type_hints["secret_store"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
            "secret_store": secret_store,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if secrets is not None:
            self._values["secrets"] = secrets

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS cluster where the secret should be created.'''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    @builtins.property
    def secret_store(self) -> "ISecretStore":
        '''The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.'''
        result = self._values.get("secret_store")
        assert result is not None, "Required property 'secret_store' is missing"
        return typing.cast("ISecretStore", result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name to use for the Kubernetes secret resource when it is synchronized into the cluster.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The name where the synchronized secret should be created.'''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[aws_cdk.Duration]:
        '''The frequency at which synchronization should occur.'''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def secrets(self) -> typing.Optional[typing.List["ISecretReference"]]:
        '''The secrets to synchronize into this Kubernetes secret.

        If multiple secrets are provided their fields will be merged.
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["ISecretReference"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalSecretsOperator(
    aws_cdk.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.ExternalSecretsOperator",
):
    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.Cluster,
        create_namespace: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster: 
        :param create_namespace: 
        :param name: 
        :param namespace: 
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecretsOperator.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalSecretsOperatorProps(
            cluster=cluster,
            create_namespace=create_namespace,
            name=name,
            namespace=namespace,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="registerSecretsManagerSecret")
    def register_secrets_manager_secret(
        self,
        id: builtins.str,
        secret: aws_cdk.aws_secretsmanager.ISecret,
        *,
        namespace: typing.Optional[builtins.str] = None,
        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> ExternalSecret:
        '''
        :param id: -
        :param secret: -
        :param namespace: 
        :param fields: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecretsOperator.register_secrets_manager_secret)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        options = NamespacedExternalSecretOptions(
            namespace=namespace, fields=fields, name=name
        )

        return typing.cast(ExternalSecret, jsii.invoke(self, "registerSecretsManagerSecret", [id, secret, options]))

    @jsii.member(jsii_name="registerSsmParameterSecret")
    def register_ssm_parameter_secret(
        self,
        id: builtins.str,
        parameter: aws_cdk.aws_ssm.IParameter,
        *,
        namespace: typing.Optional[builtins.str] = None,
        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> ExternalSecret:
        '''
        :param id: -
        :param parameter: -
        :param namespace: 
        :param fields: 
        :param name: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecretsOperator.register_ssm_parameter_secret)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
        options = NamespacedExternalSecretOptions(
            namespace=namespace, fields=fields, name=name
        )

        return typing.cast(ExternalSecret, jsii.invoke(self, "registerSsmParameterSecret", [id, parameter, options]))

    @jsii.python.classproperty
    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
    def DEFAULT_NAMESPACE(cls) -> builtins.str:
        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> aws_cdk.aws_eks.Cluster:
        return typing.cast(aws_cdk.aws_eks.Cluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="helmChart")
    def helm_chart(self) -> aws_cdk.aws_eks.HelmChart:
        return typing.cast(aws_cdk.aws_eks.HelmChart, jsii.get(self, "helmChart"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @builtins.property
    @jsii.member(jsii_name="operatorName")
    def operator_name(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "operatorName"))

    @builtins.property
    @jsii.member(jsii_name="createNamespace")
    def create_namespace(self) -> typing.Optional[builtins.bool]:
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "createNamespace"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.ExternalSecretsOperatorProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "create_namespace": "createNamespace",
        "name": "name",
        "namespace": "namespace",
    },
)
class ExternalSecretsOperatorProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.Cluster,
        create_namespace: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the Inbound Resolver resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: 
        :param create_namespace: 
        :param name: 
        :param namespace: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExternalSecretsOperatorProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument create_namespace", value=create_namespace, expected_type=type_hints["create_namespace"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if create_namespace is not None:
            self._values["create_namespace"] = create_namespace
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.Cluster:
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.Cluster, result)

    @builtins.property
    def create_namespace(self) -> typing.Optional[builtins.bool]:
        result = self._values.get("create_namespace")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretsOperatorProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FargateLogger(
    aws_cdk.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.FargateLogger",
):
    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        fargate_profiles: typing.Optional[typing.Sequence[aws_cdk.aws_eks.FargateProfile]] = None,
        log_group: typing.Optional[aws_cdk.aws_logs.ILogGroup] = None,
        log_stream_prefix: typing.Optional[builtins.str] = None,
        retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cluster: The EKS Cluster to configure Fargate logging for.
        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
        :param log_group: The CloudWatch log group where Farget container logs will be sent.
        :param log_stream_prefix: The prefix to add to the start of log streams created by the Fargate logger.
        :param retention: The number of days logs sent to CloudWatch from Fluent Bit should be retained before they are automatically removed.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateLogger.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = FargateLoggerProps(
            cluster=cluster,
            fargate_profiles=fargate_profiles,
            log_group=log_group,
            log_stream_prefix=log_stream_prefix,
            retention=retention,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addFargateProfile")
    def add_fargate_profile(
        self,
        profile: aws_cdk.aws_eks.FargateProfile,
    ) -> "FargateLogger":
        '''
        :param profile: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateLogger.add_fargate_profile)
            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
        return typing.cast("FargateLogger", jsii.invoke(self, "addFargateProfile", [profile]))

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        return typing.cast(aws_cdk.aws_eks.ICluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="logGroup")
    def log_group(self) -> aws_cdk.aws_logs.ILogGroup:
        return typing.cast(aws_cdk.aws_logs.ILogGroup, jsii.get(self, "logGroup"))

    @builtins.property
    @jsii.member(jsii_name="logStreamPrefix")
    def log_stream_prefix(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "logStreamPrefix"))

    @builtins.property
    @jsii.member(jsii_name="resource")
    def resource(self) -> aws_cdk.aws_eks.KubernetesManifest:
        return typing.cast(aws_cdk.aws_eks.KubernetesManifest, jsii.get(self, "resource"))

    @builtins.property
    @jsii.member(jsii_name="retention")
    def retention(self) -> aws_cdk.aws_logs.RetentionDays:
        return typing.cast(aws_cdk.aws_logs.RetentionDays, jsii.get(self, "retention"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.FargateLoggerProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "fargate_profiles": "fargateProfiles",
        "log_group": "logGroup",
        "log_stream_prefix": "logStreamPrefix",
        "retention": "retention",
    },
)
class FargateLoggerProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
        fargate_profiles: typing.Optional[typing.Sequence[aws_cdk.aws_eks.FargateProfile]] = None,
        log_group: typing.Optional[aws_cdk.aws_logs.ILogGroup] = None,
        log_stream_prefix: typing.Optional[builtins.str] = None,
        retention: typing.Optional[aws_cdk.aws_logs.RetentionDays] = None,
    ) -> None:
        '''Configuration for the FargateLogger resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: The EKS Cluster to configure Fargate logging for.
        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
        :param log_group: The CloudWatch log group where Farget container logs will be sent.
        :param log_stream_prefix: The prefix to add to the start of log streams created by the Fargate logger.
        :param retention: The number of days logs sent to CloudWatch from Fluent Bit should be retained before they are automatically removed.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateLoggerProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument fargate_profiles", value=fargate_profiles, expected_type=type_hints["fargate_profiles"])
            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
            check_type(argname="argument log_stream_prefix", value=log_stream_prefix, expected_type=type_hints["log_stream_prefix"])
            check_type(argname="argument retention", value=retention, expected_type=type_hints["retention"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if fargate_profiles is not None:
            self._values["fargate_profiles"] = fargate_profiles
        if log_group is not None:
            self._values["log_group"] = log_group
        if log_stream_prefix is not None:
            self._values["log_stream_prefix"] = log_stream_prefix
        if retention is not None:
            self._values["retention"] = retention

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS Cluster to configure Fargate logging for.'''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    @builtins.property
    def fargate_profiles(
        self,
    ) -> typing.Optional[typing.List[aws_cdk.aws_eks.FargateProfile]]:
        '''A default list of Fargate profiles that should have permissions configured.

        Alternatively profiles can be added at any time by calling
        ``addProfile``.
        '''
        result = self._values.get("fargate_profiles")
        return typing.cast(typing.Optional[typing.List[aws_cdk.aws_eks.FargateProfile]], result)

    @builtins.property
    def log_group(self) -> typing.Optional[aws_cdk.aws_logs.ILogGroup]:
        '''The CloudWatch log group where Farget container logs will be sent.'''
        result = self._values.get("log_group")
        return typing.cast(typing.Optional[aws_cdk.aws_logs.ILogGroup], result)

    @builtins.property
    def log_stream_prefix(self) -> typing.Optional[builtins.str]:
        '''The prefix to add to the start of log streams created by the Fargate logger.'''
        result = self._values.get("log_stream_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retention(self) -> typing.Optional[aws_cdk.aws_logs.RetentionDays]:
        '''The number of days logs sent to CloudWatch from Fluent Bit should be retained before they are automatically removed.'''
        result = self._values.get("retention")
        return typing.cast(typing.Optional[aws_cdk.aws_logs.RetentionDays], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FargateLoggerProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="cdk-extensions.k8s_aws.ISecretReference")
class ISecretReference(typing_extensions.Protocol):
    '''Represents a resource the can be synchronized into a Kubernetes secret.'''

    @jsii.member(jsii_name="bind")
    def bind(self, scope: constructs.IConstruct) -> "SecretReferenceConfiguration":
        '''Gets the configuration details for the resource being sychronized in a form that can be universally used to create the synchronization configuration.

        :param scope: The scope of the construct that will be configuring the synchronization configuration.
        '''
        ...


class _ISecretReferenceProxy:
    '''Represents a resource the can be synchronized into a Kubernetes secret.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.ISecretReference"

    @jsii.member(jsii_name="bind")
    def bind(self, scope: constructs.IConstruct) -> "SecretReferenceConfiguration":
        '''Gets the configuration details for the resource being sychronized in a form that can be universally used to create the synchronization configuration.

        :param scope: The scope of the construct that will be configuring the synchronization configuration.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ISecretReference.bind)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast("SecretReferenceConfiguration", jsii.invoke(self, "bind", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISecretReference).__jsii_proxy_class__ = lambda : _ISecretReferenceProxy


@jsii.interface(jsii_type="cdk-extensions.k8s_aws.ISecretStore")
class ISecretStore(constructs.IDependable, typing_extensions.Protocol):
    '''Represents a Kubernetes secret store resource.'''

    @builtins.property
    @jsii.member(jsii_name="secretStoreName")
    def secret_store_name(self) -> builtins.str:
        '''The name of the secret store as it appears in Kubernetes.'''
        ...


class _ISecretStoreProxy(
    jsii.proxy_for(constructs.IDependable), # type: ignore[misc]
):
    '''Represents a Kubernetes secret store resource.'''

    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.ISecretStore"

    @builtins.property
    @jsii.member(jsii_name="secretStoreName")
    def secret_store_name(self) -> builtins.str:
        '''The name of the secret store as it appears in Kubernetes.'''
        return typing.cast(builtins.str, jsii.get(self, "secretStoreName"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISecretStore).__jsii_proxy_class__ = lambda : _ISecretStoreProxy


@jsii.enum(jsii_type="cdk-extensions.k8s_aws.MetadataPolicy")
class MetadataPolicy(enum.Enum):
    '''Options for fetching tags/labels from provider secrets.'''

    FETCH = "FETCH"
    '''Fetch tags/labels from provider secrets.'''
    NONE = "NONE"
    '''Do not fetch tags/labels from provider secrets.'''


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.NamespacedExternalSecretOptions",
    jsii_struct_bases=[ExternalSecretOptions],
    name_mapping={"fields": "fields", "name": "name", "namespace": "namespace"},
)
class NamespacedExternalSecretOptions(ExternalSecretOptions):
    def __init__(
        self,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param fields: 
        :param name: 
        :param namespace: 
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NamespacedExternalSecretOptions.__init__)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fields is not None:
            self._values["fields"] = fields
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def fields(self) -> typing.Optional[typing.List["SecretFieldReference"]]:
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List["SecretFieldReference"]], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NamespacedExternalSecretOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.SecretFieldReference",
    jsii_struct_bases=[],
    name_mapping={
        "kubernetes_key": "kubernetesKey",
        "metadata_policy": "metadataPolicy",
        "remote_key": "remoteKey",
    },
)
class SecretFieldReference:
    def __init__(
        self,
        *,
        kubernetes_key: builtins.str,
        metadata_policy: typing.Optional[MetadataPolicy] = None,
        remote_key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options for how to synchronize a specific field in a secret being imported.

        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
        :param remote_key: The JSON key for the field in the secret being imported.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretFieldReference.__init__)
            check_type(argname="argument kubernetes_key", value=kubernetes_key, expected_type=type_hints["kubernetes_key"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument remote_key", value=remote_key, expected_type=type_hints["remote_key"])
        self._values: typing.Dict[str, typing.Any] = {
            "kubernetes_key": kubernetes_key,
        }
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if remote_key is not None:
            self._values["remote_key"] = remote_key

    @builtins.property
    def kubernetes_key(self) -> builtins.str:
        '''The name of the data key to be used for the field in the imported Kubernetes secret.'''
        result = self._values.get("kubernetes_key")
        assert result is not None, "Required property 'kubernetes_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metadata_policy(self) -> typing.Optional[MetadataPolicy]:
        '''Policy for fetching tags/labels from provider secrets.'''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional[MetadataPolicy], result)

    @builtins.property
    def remote_key(self) -> typing.Optional[builtins.str]:
        '''The JSON key for the field in the secret being imported.'''
        result = self._values.get("remote_key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretFieldReference(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.SecretReferenceConfiguration",
    jsii_struct_bases=[],
    name_mapping={"remote_ref": "remoteRef", "fields": "fields"},
)
class SecretReferenceConfiguration:
    def __init__(
        self,
        *,
        remote_ref: builtins.str,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''Configuration detailing how secrets are to be synchronized.

        :param remote_ref: The ID of the secret to be imported from the provider.
        :param fields: A mapping of fields and per field options to use when synchronizing a secret from a provider.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretReferenceConfiguration.__init__)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
        self._values: typing.Dict[str, typing.Any] = {
            "remote_ref": remote_ref,
        }
        if fields is not None:
            self._values["fields"] = fields

    @builtins.property
    def remote_ref(self) -> builtins.str:
        '''The ID of the secret to be imported from the provider.'''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
        '''A mapping of fields and per field options to use when synchronizing a secret from a provider.'''
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretReferenceConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ISecretReference)
class SecretsManagerReference(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.SecretsManagerReference",
):
    '''Defines a reference for importing and synchronizing a Secrets Manager secret to a Kubernetes secret.'''

    def __init__(
        self,
        secret: aws_cdk.aws_secretsmanager.ISecret,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''Creates a new instance of the SecretsManagerReference class.

        :param secret: The secret being referenced to import into Kubernetes.
        :param fields: Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerReference.__init__)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        options = SecretsManagerReferenceOptions(fields=fields)

        jsii.create(self.__class__, self, [secret, options])

    @jsii.member(jsii_name="addFieldMapping")
    def add_field_mapping(
        self,
        *,
        kubernetes_key: builtins.str,
        metadata_policy: typing.Optional[MetadataPolicy] = None,
        remote_key: typing.Optional[builtins.str] = None,
    ) -> "SecretsManagerReference":
        '''Adds a field mapping that specifies how a field from a Secrets Manager JSON secret should be mapped into the imported Kubernetes secret.

        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
        :param remote_key: The JSON key for the field in the secret being imported.

        :return: The ``SecretsManagerReference`` where the mapping was added.
        '''
        field = SecretFieldReference(
            kubernetes_key=kubernetes_key,
            metadata_policy=metadata_policy,
            remote_key=remote_key,
        )

        return typing.cast("SecretsManagerReference", jsii.invoke(self, "addFieldMapping", [field]))

    @jsii.member(jsii_name="bind")
    def bind(self, _scope: constructs.IConstruct) -> SecretReferenceConfiguration:
        '''Binds the reference to an object that is in charge of generating the manifest for the external secret.

        :param _scope: The construct that will consume the generated configuration.

        :return:

        A configuration object providing the details needed to build
        the external secret Kubernetes resource.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerReference.bind)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(SecretReferenceConfiguration, jsii.invoke(self, "bind", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="fields")
    def fields(self) -> typing.List[SecretFieldReference]:
        '''An array of field mappings which will be applied to this secret reference when mapping keys from SecretsManager JSON objects to keys in the imported secret.'''
        return typing.cast(typing.List[SecretFieldReference], jsii.get(self, "fields"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def secret(self) -> aws_cdk.aws_secretsmanager.ISecret:
        '''The secret being referenced to import into Kubernetes.'''
        return typing.cast(aws_cdk.aws_secretsmanager.ISecret, jsii.get(self, "secret"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.SecretsManagerReferenceOptions",
    jsii_struct_bases=[],
    name_mapping={"fields": "fields"},
)
class SecretsManagerReferenceOptions:
    def __init__(
        self,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''Configuration options for referencing a Secrets Manager secret as a Kubernetes secret.

        :param fields: Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerReferenceOptions.__init__)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fields is not None:
            self._values["fields"] = fields

    @builtins.property
    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
        '''Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.'''
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretsManagerReferenceOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.SecretsManagerSecretStoreProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "name": "name",
        "namespace": "namespace",
    },
)
class SecretsManagerSecretStoreProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration options for adding a new secret store resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: The EKS cluster where the secret store should be created.
        :param name: A human friendly name for the secret store.
        :param namespace: The Kubernetes namespace where the secret store should be created.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretStoreProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS cluster where the secret store should be created.'''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''A human friendly name for the secret store.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes namespace where the secret store should be created.'''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretsManagerSecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ISecretReference)
class SsmParameterReference(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.SsmParameterReference",
):
    '''Defines a reference for importing and synchronizing an SSM parameter to a Kubernetes secret.'''

    def __init__(
        self,
        parameter: aws_cdk.aws_ssm.IParameter,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''Creates a new instance of the SsmParameterReference class.

        :param parameter: The SSM parameter being referenced to import into Kubernetes.
        :param fields: Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SsmParameterReference.__init__)
            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
        options = SsmParameterReferenceOptions(fields=fields)

        jsii.create(self.__class__, self, [parameter, options])

    @jsii.member(jsii_name="addFieldMapping")
    def add_field_mapping(
        self,
        *,
        kubernetes_key: builtins.str,
        metadata_policy: typing.Optional[MetadataPolicy] = None,
        remote_key: typing.Optional[builtins.str] = None,
    ) -> "SsmParameterReference":
        '''Adds a field mapping that specifies how a field from an SSM JSON parameter should be mapped into the imported Kubernetes secret.

        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
        :param remote_key: The JSON key for the field in the secret being imported.

        :return: The ``SsmParameterReference`` where the mapping was added.
        '''
        field = SecretFieldReference(
            kubernetes_key=kubernetes_key,
            metadata_policy=metadata_policy,
            remote_key=remote_key,
        )

        return typing.cast("SsmParameterReference", jsii.invoke(self, "addFieldMapping", [field]))

    @jsii.member(jsii_name="bind")
    def bind(self, _scope: constructs.IConstruct) -> SecretReferenceConfiguration:
        '''Binds the reference to an object that is in charge of generating the manifest for the external secret.

        :param _scope: The construct that will consume the generated configuration.

        :return:

        A configuration object providing the details needed to build
        the external secret Kubernetes resource.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SsmParameterReference.bind)
            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
        return typing.cast(SecretReferenceConfiguration, jsii.invoke(self, "bind", [_scope]))

    @builtins.property
    @jsii.member(jsii_name="fields")
    def fields(self) -> typing.List[SecretFieldReference]:
        '''An array of field mappings which will be applied to this secret reference when mapping keys from SSM parameter JSON objects to keys in the imported secret.'''
        return typing.cast(typing.List[SecretFieldReference], jsii.get(self, "fields"))

    @builtins.property
    @jsii.member(jsii_name="parameter")
    def parameter(self) -> aws_cdk.aws_ssm.IParameter:
        '''The SSM parameter being referenced to import into Kubernetes.'''
        return typing.cast(aws_cdk.aws_ssm.IParameter, jsii.get(self, "parameter"))


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.SsmParameterReferenceOptions",
    jsii_struct_bases=[],
    name_mapping={"fields": "fields"},
)
class SsmParameterReferenceOptions:
    def __init__(
        self,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''Configuration options for referencing an SSM parameter as a Kubernetes secret.

        :param fields: Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SsmParameterReferenceOptions.__init__)
            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
        self._values: typing.Dict[str, typing.Any] = {}
        if fields is not None:
            self._values["fields"] = fields

    @builtins.property
    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
        '''Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.'''
        result = self._values.get("fields")
        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SsmParameterReferenceOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-extensions.k8s_aws.SsmParameterSecretStoreProps",
    jsii_struct_bases=[aws_cdk.ResourceProps],
    name_mapping={
        "account": "account",
        "environment_from_arn": "environmentFromArn",
        "physical_name": "physicalName",
        "region": "region",
        "cluster": "cluster",
        "name": "name",
        "namespace": "namespace",
    },
)
class SsmParameterSecretStoreProps(aws_cdk.ResourceProps):
    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        cluster: aws_cdk.aws_eks.ICluster,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration options for adding a new secret store resource.

        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        :param cluster: The EKS cluster where the secret store should be created.
        :param name: A human friendly name for the secret store.
        :param namespace: The Kubernetes namespace where the secret store should be created.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SsmParameterSecretStoreProps.__init__)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if account is not None:
            self._values["account"] = account
        if environment_from_arn is not None:
            self._values["environment_from_arn"] = environment_from_arn
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if region is not None:
            self._values["region"] = region
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID this resource belongs to.

        :default: - the resource is in the same account as the stack it belongs to
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def environment_from_arn(self) -> typing.Optional[builtins.str]:
        '''ARN to deduce region and account from.

        The ARN is parsed and the account and region are taken from the ARN.
        This should be used for imported resources.

        Cannot be supplied together with either ``account`` or ``region``.

        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        '''
        result = self._values.get("environment_from_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def physical_name(self) -> typing.Optional[builtins.str]:
        '''The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        :default: - The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("physical_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The AWS region this resource belongs to.

        :default: - the resource is in the same region as the stack it belongs to
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS cluster where the secret store should be created.'''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_eks.ICluster, result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''A human friendly name for the secret store.'''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The Kubernetes namespace where the secret store should be created.'''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SsmParameterSecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ISecretStore)
class AwsSecretStore(
    aws_cdk.Resource,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.AwsSecretStore",
):
    '''A generic class representing secret store that is backed by an AWS service.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        service: builtins.str,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the AwsSecretStore class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
        :param cluster: The EKS cluster where the secret store should be created.
        :param service: The name of the service provider backing the secret store.
        :param name: A human friendly name for the secret store.
        :param namespace: The Kubernetes namespace where the secret store should be created.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsSecretStore.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AwsSecretStoreProps(
            cluster=cluster,
            service=service,
            name=name,
            namespace=namespace,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.python.classproperty
    @jsii.member(jsii_name="NAME_VALIDATOR_REGEX")
    def NAME_VALIDATOR_REGEX(cls) -> builtins.str:
        '''The regex pattern used to validate secret store names.'''
        return typing.cast(builtins.str, jsii.sget(cls, "NAME_VALIDATOR_REGEX"))

    @builtins.property
    @jsii.member(jsii_name="cluster")
    def cluster(self) -> aws_cdk.aws_eks.ICluster:
        '''The EKS cluster where the secret store should be created.

        :group: Inputs
        '''
        return typing.cast(aws_cdk.aws_eks.ICluster, jsii.get(self, "cluster"))

    @builtins.property
    @jsii.member(jsii_name="manifest")
    def manifest(self) -> aws_cdk.aws_eks.KubernetesManifest:
        '''The Kubernetes manifest that defines the secret store.

        :group: Resources
        '''
        return typing.cast(aws_cdk.aws_eks.KubernetesManifest, jsii.get(self, "manifest"))

    @builtins.property
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''A human friendly name for the secret store.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property
    @jsii.member(jsii_name="namespace")
    def namespace(self) -> builtins.str:
        '''The Kubernetes namespace where the secret store should be created.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "namespace"))

    @builtins.property
    @jsii.member(jsii_name="secretStoreName")
    def secret_store_name(self) -> builtins.str:
        '''The name of the secret store as it appears in Kubernetes.'''
        return typing.cast(builtins.str, jsii.get(self, "secretStoreName"))

    @builtins.property
    @jsii.member(jsii_name="service")
    def service(self) -> builtins.str:
        '''The name of the service provider backing the secret store.

        :group: Inputs
        '''
        return typing.cast(builtins.str, jsii.get(self, "service"))

    @builtins.property
    @jsii.member(jsii_name="serviceAccount")
    def service_account(self) -> aws_cdk.aws_eks.ServiceAccount:
        '''A Kubernetes service account mapped to an IAM role that provides the necessary permissions to sychronize secrets from an AWS rpvoder.

        :group: Resources
        '''
        return typing.cast(aws_cdk.aws_eks.ServiceAccount, jsii.get(self, "serviceAccount"))


class SecretsManagerSecretStore(
    AwsSecretStore,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.SecretsManagerSecretStore",
):
    '''A secret store that allows secrets from AWS Secrets Managers to be synchronized into Kubernetes as Kubernetes secrets.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the SecretsManagerSecretStore class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
        :param cluster: The EKS cluster where the secret store should be created.
        :param name: A human friendly name for the secret store.
        :param namespace: The Kubernetes namespace where the secret store should be created.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretStore.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SecretsManagerSecretStoreProps(
            cluster=cluster,
            name=name,
            namespace=namespace,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSecret")
    def add_secret(
        self,
        id: builtins.str,
        secret: aws_cdk.aws_secretsmanager.ISecret,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> ExternalSecret:
        '''Registers a new Secrets Manager secret to be synchronized into Kubernetes.

        :param id: The ID of the secret import configuration in the CDK construct tree. The configuration is placed under the Secrets Manager secret it synchronizes and so must be unique per secret.
        :param secret: The Secrets Manager secret to synchronize into Kubernetes.
        :param fields: 
        :param name: 

        :return: The external secret configuration that was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretStore.add_secret)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        options = ExternalSecretOptions(fields=fields, name=name)

        return typing.cast(ExternalSecret, jsii.invoke(self, "addSecret", [id, secret, options]))


class SsmParameterSecretStore(
    AwsSecretStore,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-extensions.k8s_aws.SsmParameterSecretStore",
):
    '''A secret store that allows parameters from Systems Manager to be synchronized into Kubernetes as Kubernetes secrets.'''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cluster: aws_cdk.aws_eks.ICluster,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Creates a new instance of the SsmParameterSecretStore class.

        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
        :param cluster: The EKS cluster where the secret store should be created.
        :param name: A human friendly name for the secret store.
        :param namespace: The Kubernetes namespace where the secret store should be created.
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SsmParameterSecretStore.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SsmParameterSecretStoreProps(
            cluster=cluster,
            name=name,
            namespace=namespace,
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSecret")
    def add_secret(
        self,
        id: builtins.str,
        parameter: aws_cdk.aws_ssm.IParameter,
        *,
        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[str, typing.Any]]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> ExternalSecret:
        '''Registers a new SSSM parameter to be synchronized into Kubernetes.

        :param id: The ID of the secret import configuration in the CDK construct tree. The configuration is placed under the SSM parameter it synchronizes and so must be unique per secret.
        :param parameter: The SSM parameter to synchronize into Kubernetes.
        :param fields: 
        :param name: 

        :return: The external secret configuration that was added.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SsmParameterSecretStore.add_secret)
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
        options = ExternalSecretOptions(fields=fields, name=name)

        return typing.cast(ExternalSecret, jsii.invoke(self, "addSecret", [id, parameter, options]))


__all__ = [
    "AwsSecretStore",
    "AwsSecretStoreProps",
    "CloudWatchMonitoring",
    "CloudWatchMonitoringProps",
    "ExternalDns",
    "ExternalDnsProps",
    "ExternalSecret",
    "ExternalSecretOptions",
    "ExternalSecretProps",
    "ExternalSecretsOperator",
    "ExternalSecretsOperatorProps",
    "FargateLogger",
    "FargateLoggerProps",
    "ISecretReference",
    "ISecretStore",
    "MetadataPolicy",
    "NamespacedExternalSecretOptions",
    "SecretFieldReference",
    "SecretReferenceConfiguration",
    "SecretsManagerReference",
    "SecretsManagerReferenceOptions",
    "SecretsManagerSecretStore",
    "SecretsManagerSecretStoreProps",
    "SsmParameterReference",
    "SsmParameterReferenceOptions",
    "SsmParameterSecretStore",
    "SsmParameterSecretStoreProps",
]

publication.publish()
