# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['wintry',
 'wintry.cli',
 'wintry.cli.commands',
 'wintry.cli.templates',
 'wintry.cli.templates.generate',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.contrib',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}.entrypoints',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}.inputs',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}.models',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}.repositories',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}.services',
 'wintry.cli.templates.project.{{cookiecutter.project_name}}.apps.{{cookiecutter.project_name}}.views',
 'wintry.errors',
 'wintry.ioc',
 'wintry.mapper',
 'wintry.mqs',
 'wintry.repository',
 'wintry.testing',
 'wintry.transactions',
 'wintry.transporters',
 'wintry.utils']

package_data = \
{'': ['*'], 'wintry.cli.templates': ['project/*']}

install_requires = \
['SQLAlchemy==1.4.35',
 'aio-pika>=7.2.0,<8.0.0',
 'aioredis>=2.0.1,<3.0.0',
 'aiosqlite>=0.17.0,<0.18.0',
 'asyncpg>=0.25.0,<0.26.0',
 'cookiecutter>=1.7.3,<2.0.0',
 'fastapi>=0.78.0,<0.79.0',
 'mongomock>=4.0.0,<5.0.0',
 'motor>=2.5.1,<3.0.0',
 'odmantic>=0.5.0,<0.6.0',
 'pydantic==1.9.0',
 'redis>=4.3.4,<5.0.0',
 'sqlmodel>=0.0.6,<0.0.7',
 'typer[all]>=0.4.1,<0.5.0',
 'uvicorn[standard]>=0.17.6,<0.18.0',
 'wrapt>=1.14.1,<2.0.0']

entry_points = \
{'console_scripts': ['snowman = wintry.cli.cli:snowman']}

setup_kwargs = {
    'name': 'wintry',
    'version': '0.1.5',
    'description': 'A modern python web framework based on python-3.10',
    'long_description': '<img src="docs/img/logo.jpg" />\n\n# ‚ùÑÔ∏èüêßA modern python web frameworküêß‚ùÑÔ∏è\n\n![](https://img.shields.io/static/v1?label=code&message=python&color=<blue>&style=plastic&logo=github&logoColor=4ec9b0)\n![](https://img.shields.io/static/v1?label=web&message=framework&color=<blue>&style=plastic&logo=github&logoColor=4ec9b0)\n![](https://img.shields.io/static/v1?label=Tests&message=Passing&color=<blue>&style=plastic&logo=github&logoColor=4ec9b0)\n![](https://img.shields.io/static/v1?label=pypi%20package&message=v0.1.0&color=<blue>&style=plastic&logo=github&logoColor=4ec9b0)\n\n!!! Note\n FRAMEWORK\'S API IS CONSTANTLY EVOLVING. I PLAN TO GIVE A STABLE VERSION WITH THE 1.0.0\n RELEASE. BUT GIVE IT A TRY, IT MIGHT BECOME A GOOD FRIEND OF YOURS :)\n\nHello, friend, welcome to üêß**Wintry**üêß. You may have stumble with this project searching\nfor a python web framework, well, you got what you want.\n\nPherhaps you know many other frameworks, pherhaps you know Django, or maybe Flask,\nor hopefully FastAPI. And odds are that you are willing to take a new project for a\nride with a new alternative. Well, üêß**Wintry**üêß is just that, your new alternative, one that\ndo not push you out of your comfort zone, one that do not get in your away, no matter how\nmuch you scale.\n\nBeign accured, if you have used FastAPI, you would feel at home, üêß**Wintry**üêß is heavilly\ninspired in FastAPI, it actually uses it whenever it can. But it adds a bunch of \nüòé\'cool\'üÜí stuff on top.\n\n## Inspirations\n---------------\n\nI have used FastAPI a lot for the last year, and I am absolutely fascinated about it.\nSpeed + Python on the same sentence, that\'s something to really appreciate. I know, a big\nthanks to [starlette](https://github.com/encode/starlette) project which is the real hero on \nthat movie, but, FastAPI adds a ton\nof cool features on top: if I would describe them in three words, it would be: Pydantic \nand Dependency Injection.\n\nOn the other hand, we have [Django](https://github.com/django/django), a full-featured Framework,\nwhich has an implementation for nearly everything you could imagine. But it is really opinionated\nabout how to do stuff. When a project starts to get big, usually developers found themselves\nfighting the framework, instead of using it, just because they were trying to apply patterns and\ntechniques for which the framework was not designed for. FastAPI is like the sweet spot here,\nbecause it offers just enough to get you started fast, and then you can use a vast ecosystem\nto flesh it as your project gets big. And that\'s the problem. Too many tools, too many ways\nthey can be combined, to many relations that can be configured, and can potentially go wrong.\n\nIs cool when you can build a rest api with 10 lines of code. Is cool when you see Pydantic used\nin such a clever way to achieve model-binding at request time. Is cool that FastAPI gives us\nalready scoped (Request based) dependency injection. But if we are coming from .NET, or Spring,\nor we are really committed to Microservices or Fully Decoupled Monolith with advanced techniques\nsuch as CQRS and DDD, we start missing some good old controllers, some good old Constructor\nbased IoC. Also, it would be nice to have some form of Repository, right? Maybe some support for\nCommand and Query separation (And Eventsü§û). What about atomic transactions, can we have that too ?\nAnd please, support for SQL and NoSQL DB üòä, because that\'s trending, and I want to split\nmy data into Write models and read models. Speaking of which, allow me to easily configure more\nthan one DB right. And please, I love the ORM and change tracking functionalities of SQLAlchemy,\ncan we have that for all our DB and integrated with the atomic transactions ? And can we .....\n\nYeah, a lot of good features, and all of them fully compatible with each other. That\'s what\nüêß**Wintry**üêß is all about. Be opinionated about some conventions and provide a large\nrange of tools, fully compatible with each other, that allows you, the developer, to\n"DESIGN" and "IMPLEMENT" your system in the way you want, without the framework interposing\nin your way, with the performance of the latest technologies, with the language that we all\nlove üòä.\n\nSounds good right ? Lets see how it looks like\n\n```python\nfrom wintry import (SQLEngineContext, scoped, DbContext, AsyncSession, SQLModel,\n                    AbstractRepository, SQLRepository, controller, get, post, atomic, App, AppBuilder,\n                    ObjectId)\nfrom wintry.sql import Field\nfrom pydantic import BaseModel\n\n@scoped\nclass AppDbContext(AsyncSession, DbContext):\n    def __init__(self):\n        super().__init__(SQLEngineContext.get_client(), expire_on_commit=False)\n\n    async def dispose(self):\n        await self.close()\n\nclass Hero(SQLModel, table=True):\n    id: str | None = Field(primary_key=True, default_factory=lambda: str(ObjectId()))\n    name: str\n    city: str | None = None\n\nclass CreateHeroModel(BaseModel):\n    name: str\n    city: str | None = None\n    \n@scoped(of=AbstractRepository[Hero, str])\nclass HeroRepo(SQLRepository):\n    def __init__(self, context: AppDbContext):\n        super().__init__(context, Hero)\n\n@controller\nclass HeroesController(object):\n    heroes: AbstractRepository[Hero, str]\n\n    @get("/", response_model=list[Hero])\n    async def get_heroes(self):\n        return await self.heroes.find()\n\n    @post("/")\n    @atomic(with_context=AppDbContext)\n    async def create_hero(self, create_hero_model: CreateHeroModel):\n        new_hero = Hero.from_orm(create_hero_model)\n        await self.heroes.add(new_hero)\n        return "Ok"\n\napp = App()\nAppBuilder.use_sql_context(app, SQLEngineContext, "sqlite+aiosqlite:///:memory:")\n```\n\nCool ehh !?. Right now, you would have a fully-featured app. It is not your typical "hello world" app,\nbecause that\'s boring. Instead, you now have an api, that creates and list heroes, with a clear separation\nof your models, data access, and a presentation layer in the form of controllers. A paradise for testing and\ndecoupling. Furthermore, you have the ```@atomic``` decorator, which will roll-back your db changes\nwhenever an error occurs withing the post method. You have, as expected from FastAPI, a fully documented\nAPI, with type annotations everywhere. Even more, you have a repository automatically created for you,\nand the controller already depends on an abstraction, not the concrete repo, so it could easily be changed\nfor a mock for testing or whatever you want. Almost forgot, you can exchange the DB provider for any async\nbackend, sqlalchemy will handle it for you üòâ.\n\nUmm, but I want to use MongoDB, now, can I do it. YES!! Of course you can, and even more,\nbecause you only depend on abstractions to build your controllers, it is now really easy\nto swap the implementation for a NoSQL one.\n\nFirst we need to use a different context\n```python\nfrom wintry import scoped\nfrom wintry import NosqlAsyncSession\nfrom wintry import DbContext\nfrom wintry import MotorContext\n\n@scoped\nclass MongoContext(NosqlAsyncSession, DbContext):\n    def __init__(self):\n        super().__init__(MotorContext.get_client(), database="test")\n\n    async def dispose(self):\n        pass\n```\n\nThen we register the new repository and remove the SQLModel from our model\n\n```python\nfrom wintry import NoSQLModel\nfrom wintry import NoSQLRepository\nfrom odmantic.bson import ObjectId\n\nclass Hero(NoSQLModel):\n    id : str = Field(primary_field=True, default_factory=lambda: str(ObjectId()))\n    name: str\n    city: str | None = None\n    \n@scoped(of=AbstractRepository[Hero, str])\nclass HeroRepo(NoSQLRepository):\n    def __init__(self, context: MongoContext):\n        super().__init__(context, Hero)\n```\n\nAnd finally we register our new backend\n\n```python\nAppBuilder.use_mongo_context(app, MotorContext, "mongodb://localhost:27017")\n```\nThat\'s it. Our controller still will be working the same.\n\nSide Note !!: If you run your application with:\n```commandline\n $ gunicorn -w 4 -k uvicorn.workers.UvicornWorker main:app \n```\nYou will see a surprise. Usually, when using MongoDb with Motor for the async Backend, and run\nthe app with gunicorn, because of the global client, the app will crash, with a Detached Task error.\nYou might be surprised that wintry handles this case for you, be defining the client inside a\nContext var on the MotorContext, and then, retrieving it on each request when instantiating\nthe MongoContext, that\'s what `MotorContext.get_client()` is intended for.\n\nIf you are diving into Clean Architecture, DDD, and some advance stuff, you might be\nunconformable by changing your model, after all, my hero should be just fine with its\nnew data store, it should not even care about ir right !?.\n\nWell, that\'s pretty easy to achieve using SQLAlchemy (and soon with NoSQL too, thanks to\nthe incoming mapping layer for nosql-wintry). We can use imperative mapping as described\n[here](https://docs.sqlalchemy.org/en/14/orm/mapping_styles.html#imperative-mapping),\nand now our Hero will be a pure Python Object, and our repos will still behave the same,\nand you can go and tweak your DB as much as you need and maintain our domain models as\nclean as possible.\n\nSo far so good. At this point, wintry will prove to be really helpful, but it is not\nbringing too much new to the table right ? I mean, yeah, you got repositories, decoupling\nwith abstractions, some fancy config API for setting up new DB Contexts as we can do\nin .NET, we have Dependency Injection .... , wait, I said Dependency Injection, do I said\nfully compatible with FASTAPI üò±üò±!!!???\n\nIf you have used FastAPI before, you may have noticed that Dependencies, are not truly\nDependency Injection, is more like a Request Bound Resolution method, which is really cool\nand helpful, but at the same time, tides you to the controller level. Furthermore, if I want\nto use the same dependency in a bunch of methods, I will have to either replicate that\ndependency on each method signature, or rescind from its return value. Imagine that you\nwant to secure now your two endpoints, using the same approach as the security section\nin the FastAPI tutorial. In order to access the user information inside the endpoint,\nyou will have to declare something like this\n```python\n@app.get("/")\nasync def my_awsome_endpoint(user: Depends(get_logged_user)):\n    ...\n```\n\nNot cool. I want to secure all my endpoints inside a controller and I don\'t want to\nrepeat my self. FastAPI with a penguin to the rescue, inside controllers, you can use\nyour FastAPI dependencies as usual, BUT, you can access their values, like this:\n\n```python\n@controller\nclass MyAwsomeController:\n    user: LoggedUser = Depends(get_logged_user)\n\n    @get("/")\n    async def secured_endpoint(self):\n        return self.user\n```\n\nBut wait, there is a lot more, the **@scoped** decorator\nallows the repository to be injected inside the controller\nconstructor, just like happens in .NET Core or Java Spring, and combine\nit with the FastAPI Dependency Injection for giving you, the developer,\nan extremely powerful tool to extend, reuse and configure your entire\napplication (tip: Most of the FastAPI ecosystem is build around Dependency Injection).\nIn fact, wintry relies heavily on the IoC (Inversion of Control) module, which, is\nI like to call the Igloo.\n\nNon-Fastapi DI is configured using two decorators: **@scoped** and **@provider**, which\ngives you the ability to create Scoped (request bound), Transient (on demand) and Singleton\ninstances for each declared dependency. To prepare an object for injection, you could\nuse the **@inject** decorator. **@scoped** and **provider** mark their classes or functions\nfor injection as well. Other decorators already prepare their targets for injection, as\n**@controller** and **@microservice**\n\n## Installation\n---------------\nAs simple as use\n\n```\n$ pip install wintry\n```\n\nor with poetry\n\n```\n$ poetry add wintry\n```\n\n## Features\n-----------\nThere is a lot more to know about Wintry:\n\n* Stack of patterns (RepositoryPattern, UnitOfWork, ProxyPattern,\nMVC, Event-Driven-Desing,\nCQRS, etc.)\n\n* Automatic Relational Database metadata creation.\n\n* Automatic Query Creation.\n\n* Reactive Domain Models.\n\n* Dependency Injection (Next Level).\n\n* Transactional methods. This a really powerful feature that pairs with Dependency Injection\nand Command&Event handler, providing a robust implementation of atomic write/update/delete operations.\n\n* Publisher Subscribers.\n\n* Services.\n\n* Domain Model based on dataclasses.\n\n* Short: Focus on what really matters, write less code, get more results.\n\n* Everything from FastAPI in a really confortable way\n\n* Settings based on Pydantic.\n\n* A handy cli for managing projects (Feeling jealous of Rails ?? Not any more): Work in progress.\n\n\n## ROADMAP\n----------\n* Performance similar to FastAPI (When possible, actually FastAPI is a LOWER BOUND) (need benchmarks and identify bottle necks).\n\n* Create documentation\n\n* Add more features to the feature list with links to\nthe corresponding documentation\n\n* Add RPC support (Maybe protobuf, raw TCP, Redis, RabbitMQ, Kafka, etc)\n\n* Ease registration of Middlewares\n\n* Provide Implementation of Authorization Services\n\n* Create CLI for managing project\n\n* Provide Support for migrations (from the cli)\n\n* Templates\n\n* Maybe some ViewEngine (Most likely will be based on Jinja2)\n\n* Implement a builtin Admin (Similar to Django), but taking advantage of the registry system.\nCool stuff here, perhaps we can dynamically create models and manage the databases in the admin\nwith a UI. IDK, maybe, just maybe.\n\n## Contributions\n----------------\n\nEvery single contribution is very appreciated. From ideas, issues,\nPR, criticism, anything you can imagine.\n\nIf you are willing to provide a PR for a feature, just try to\ngive at least some tests for the feature, I do my best\nmantaining a pool of tests that will be growing with time\n\n- [Issue Tracker](https://github.com/adriangs1996/wintry/issues)\n\n- [Fork the repo, change it, and make a PR](https://github.com/adriangs1996/wintry)\n\n## Thanks\n--------\nTo @tiangolo for the amazing [SQLModel](https://github.com/tiangolo/sqlmodel) and [FastAPI](https://github.com/tiangolo/fastapi)\n\nTo the amazing [Django Team](https://github.com/django/django)\n\nTo the Spring Project and [NestJS](https://nestjs.com/) for such amazing frameworks\n\n\nLicense\n-------\n\nThis project is licensed under the MIT License',
    'author': 'adriangs1996',
    'author_email': 'adriangonzalezsanchez1996@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://adriangs1996.github.io/wintry',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
