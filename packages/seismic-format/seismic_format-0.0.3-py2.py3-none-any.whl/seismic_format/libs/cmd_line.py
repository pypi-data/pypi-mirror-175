"""
   Common functions for cmd line parsing

   *** Do NOT edit this file directly
       (it will be overwritten by next sync)
   *** Edit master file in:
       .../cmd-log/cmd_line.py

   This file gets synced to:
       o aqms-pdl/aqms_pdl/libs/cmd_line.py
       o aqms-mkv0/aqms_mkv0/libs/cmd_line.py
"""

import argparse
import os
import sys

from collections import namedtuple
fields = ['arg', 'type', 'description', 'help', 'default']
required_arg = namedtuple('required', fields, defaults=[None,] * len(fields))
optional_arg = namedtuple('optional', fields, defaults=[None,] * len(fields))


def parse_cmd_line(required_args=[], optional_args=[], expand_wildcards=False, flag_configfile=True):
    """
    Create common Usage with [--loglevel ] [--logfile ] [--logconsole]
      and add any specific fields from required_args
    """

    fname = os.path.basename(sys.argv[0])

    parser = argparse.ArgumentParser()
    optional = parser.add_argument_group("optional arguments")
    required = parser.add_argument_group("required arguments")

    LOGLEVELS = ['DEBUG', 'INFO', 'WARN', 'ERROR']

    if flag_configfile:
        # Only allow -c path/to/config.yml if -c is NOT already being used by app (e.g., -c cha)
        add_c = True
        for arg in required_args + optional_args:
            #print(arg)
            for a in arg.arg:
                #print(a)
                if a == '-c':
                    add_c = False
                    break
        config_flags = ['--configfile', '--configFile', '--config-file', '--config_file']
        if add_c:
            config_flags.append('-c')

        config_is_required = False
        for r_arg in required_args:
            for arg in r_arg.arg:
                if arg in config_flags:
                    config_is_required = True
                    break

        # Only add optional configfile arg if it's not already in required args
        if not config_is_required:
            #optional.add_argument("--configfile", "-c", "--configFile", type=str, metavar='path/to/config.yml')
            optional.add_argument(*config_flags, type=str, metavar='path/to/config.yml')

    optional.add_argument("--loglevel", "--log-level", type=str, choices=LOGLEVELS,
                          default='INFO',
                          metavar=', '.join(LOGLEVELS), help='[Default = INFO]')
    # MTH: Set logconsole default in configure_logger, not here
    optional.add_argument("--logconsole", action="store_true", help='[Default = True if logfile not set]')
    optional.add_argument("--logfile", type=str, metavar='/path/to/logfile')
    optional.add_argument("--logdir", "--log-dir", type=str, metavar='/path/to/logfile')

    for r in required_args + optional_args:
        arg_is_required = True if isinstance(r, required_arg) else False
        name = r.arg
        r_type = r.type
        description = r.description
        help_msg = r.help

        positional = True if len(name) == 1 and name[0][0] != '-' else False

        #print("add_argument name=%s required=%s positional=%s r_type=%s description:%s help:%s" %
              #(name, arg_is_required, positional, r_type, description, help_msg))
        #print("default:", r.default)

        #name is a list and could be for example: ['-f', '--infile', '--infiles']

        isFile = [n for n in name if 'file' in n]

        kwargs = {'metavar':description, 'help':help_msg, 'default':r.default}

        if expand_wildcards and isFile:
            kwargs['nargs'] = '+'
        elif r_type == bool:
            kwargs['action'] = 'store_true'
            # can't have store_true + metavar
            kwargs.pop('metavar', None)
        else:
            kwargs['type'] = r_type
        # positional args are *always* required and do *not* take the 'required' keyword
        if arg_is_required and not positional:
            kwargs['required'] = True

        if arg_is_required:
            # MTH: this is known to bomb if required_arg.description = None and we have optional_args
            required.add_argument(*name, **kwargs)
        else:
            optional.add_argument(*name, **kwargs)


    args, unknown = parser.parse_known_args()

    if unknown:
        print("The following cmd line params are unknown:%s" %(" ".join(unknown)))
        parser.print_usage()
        exit(2)

    return args, parser


if __name__ == "__main__":
    main()
