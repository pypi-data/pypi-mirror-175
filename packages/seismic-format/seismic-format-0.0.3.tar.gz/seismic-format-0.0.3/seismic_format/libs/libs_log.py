"""
   Common functions for logging

   *** Do NOT edit this file directly
       (it will be overwritten by next sync)
   *** Edit master file in:
       .../cmd-log/libs_log.py

   This file gets synced to:
       o aqms-pdl/aqms_pdl/libs/libs_log.py
"""

import os
import sys

import logging

from logging.handlers import TimedRotatingFileHandler

def configure_logger(**kwargs):
    '''
        levelString = 'INFO' or 'WARN' or 'WARNING', etc
    '''

    formatter = logging.Formatter('%(asctime)s [%(levelname)5s] %(message)s')
    logger = logging.getLogger()

    # DEFAULTS
    DEFAULT_LEVELSTRING = 'INFO'

    logfile = None
    logdir = None
    levelString = DEFAULT_LEVELSTRING
    for k,v in kwargs.items():
        if k.lower() in ['log_level', 'loglevel']:
            levelString = v.upper() if v else DEFAULT_LEVELSTRING
        if k.lower() in ['logfile']:
            logfile = v
        if k.lower() in ['log_dir', 'logdir']:
            logdir = v

    logger.level = string_to_logLevel(levelString)

    if logdir and not logfile:
        logfile = os.path.basename(sys.argv[0])

    if logfile is not None:
        if not logdir:
            logdir = os.path.dirname(logfile)

        logfile = os.path.join(logdir, os.path.basename(logfile))

        #print("libs_log logdir=[%s] logfile=[%s]" % (logdir, logfile))

        # if logfile=name.log and logdir was not passed in, then logdir will be empty string
        if logdir and not os.path.exists(logdir):
            try:
                os.makedirs(logdir)
            except:
                raise
        # create file handler 
        fh = TimedRotatingFileHandler(logfile, when="midnight")
        fh.setFormatter(formatter)
        logger.addHandler(fh)

    # MTH: Default logconsole=True if no logfile/logdir set:
    if ('logconsole' in kwargs and kwargs['logconsole']) \
       or logfile is None:
        # create console handler 
        ch = logging.StreamHandler()
        ch.setFormatter(formatter)
        logger.addHandler(ch)

    return logger


def string_to_logLevel(levelString):
    '''
       levelString = 'INFO' or 'WARN' or 'WARNING', etc
    '''
    loglevels = {"ERROR": logging.ERROR, "WARN": logging.WARNING,
                 "WARNING": logging.WARNING, "INFO": logging.INFO,
                 "DEBUG": logging.DEBUG, "CRITICAL": logging.CRITICAL,
                }
    if levelString in loglevels:
        return loglevels[levelString]
    else:
        msg = " ".join(list(loglevels.keys()))
        print("ERROR: Unknown --loglevel=%s (not in:{%s})" % (levelString, msg))
        exit(2)


def update_args_with_config(args, config, fname=None):

    # cmd line args override config file:

    # See if there's enough info to set logfile
    #   else set logconsole
    if args.logfile is None:
        if config and 'logfile' in config:
            args.logfile = config['logfile']
        elif fname and config and 'LOG_DIR' in config:
            args.logfile = os.path.join(config['LOG_DIR'], "%s.log" % fname)
        elif fname and 'logdir' in args and args.logdir:
            args.logfile = os.path.join(args.logdir, "%s.log" % fname)
        # log to console by default if no logfile specified
        else:
            args.logconsole = True
    elif args.logdir:
        args.logfile = os.path.join(args.logdir, args.logfile)

    if config is None:
        return

    if args.logconsole is None and 'logconsole' in config:
        args.logconsole = config['logconsole']

    if args.loglevel is None and 'LOG_LEVEL' in config:
        args.loglevel = config['LOG_LEVEL']

    # Any other params in config that *aren't* contained in cmd line args,
    #     add to args *except* for DB connect params that stay with config
    for k,v in config.items():
        if getattr(args, k, None) is None:
        #if k not in args or args.k is None:
            if k not in ['DB_HOST', 'DB_NAME', 'DB_PORT', 'DB_USER', 'DB_PASSWORD']:
                #print("k=%s in config --> add to args" % k)
                setattr(args, k.lower(), v)

    return


# ===========================  read config functions below  =========================
import yaml

from .. import installation_dir

def read_config(requireConfigFile=True, configfile=None, debug=False):

    fname = 'read_config'
    config = None

    #log_msgs = []
    log_msgs = {}
    log_msgs['info'] = []
    log_msgs['warn'] = []
    log_msgs['error'] = []

    # From highest to lowest priority location of config.yml:
    # 1. passed on cmd line --configFile=...
    # 2. os.getcwd() = Location script is called from
    # 3. from env AQMS_DB_CONFIG
    # 4. INSTALL_DIR = Location of yasmine_cli directory
    # 5. None


    if configfile:
        log_msgs['info'].append("%s: configfile passed in:%s" % (fname, configfile))

    if configfile is None:
    # See if it was passed on cmd line:
        if debug:
            print("aqms-pdl read_config() check if configfile was passed on cmd line")
        configfile = pick_off_configFile(sys.argv[1:], debug)
        #if debug and configfile:
        if configfile:
            log_msgs['info'].append("%s: Read from --configfile=[%s]" % (fname, configfile))

    if configfile is None:
        if debug:
            print("aqms-pdl read_config() Look in CWD")
        # Look for config.yml in dir where pdl-to-aqms is called from (changes)
        test_path = os.path.join(os.getcwd(), 'config.yml')
        if os.path.exists(test_path):
            configfile = test_path
        if configfile:
            log_msgs['info'].append("%s: Read from CWD ./config.yml" % (fname))

    if configfile is None:
        if debug:
            print("aqms-pdl read_config() check ENV AQMS_DB_CONFIG")
        configfile = os.getenv('AQMS_DB_CONFIG')
        if configfile:
            log_msgs['info'].append("%s: Read from env var AQMS_DB_CONFIG-->configfile:%s" % (fname, configfile))

    if configfile is None:
        if debug:
            print("aqms-pdl read_config() Look in INSTALL_DIR")
        # Look for config.yml in dir where pdl_to_aqms.py is located (it never changes)
        #SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
        #test_path = os.path.join(SCRIPT_DIR, 'config.yml')
        INSTALL_DIR = installation_dir()
        test_path = os.path.join(INSTALL_DIR, 'config.yml')
        if os.path.exists(test_path):
            configfile = test_path
        if configfile:
            log_msgs['info'].append("%s: Read from configfile:config.yml in installadtion_dir:%s" % (fname, INSTALL_DIR))

    if configfile:
        config, err = parse_config(configfile)
        if config is None:
            log_msgs['error'].append(err)
            return None, log_msgs

        # MTH: I could allow user to specify the entire db connection via user ENV vars
        #      but this code is used by apps that modify (insert/delete) a db
        #      hence I prefer to force user to explicitly specify db HOST + NAME in config file
        #      so they don't accidentally modify the wrong db
        #for param in ['DB_HOST', 'DB_NAME', 'DB_PORT', 'DB_USER', 'DB_PASSWORD']
        if 'DB_HOST' in config and 'DB_NAME' in config:
            missing_param = False
            for param in ['DB_PORT', 'DB_USER', 'DB_PASSWORD']:
                if param not in config:
                    val = os.getenv(param, None)
                    if val:
                        config[param] = val
                    else:
                        #print("ERROR: param=%s is not specified in configfile or in ENV --> Exitting!" % param)
                        log_msgs['error'].append("param=%s is not specified in configfile or in ENV --> Exitting!" % param)
                        missing_param = True
                        #exit(2)
            if missing_param:
                return None, log_msgs

            config["conn_string"] = "host=%s dbname=%s port=%s user=%s password=%s" % \
                (config['DB_HOST'], config['DB_NAME'], config['DB_PORT'],
                config['DB_USER'], config['DB_PASSWORD'])

            config["sqlalchemy.url"] = "postgresql://{}:{}@{}:{}/{}".format(
                config['DB_USER'], config['DB_PASSWORD'], config['DB_HOST'],
                config['DB_PORT'], config['DB_NAME'])

        return config, log_msgs
    else:
        if requireConfigFile:
            #logger.ERROR("ConfigFile is required but none has been found --> Exit")
            log_msgs['error'].append("ConfigFile is required but none has been found --> Exit")
            log_msgs['info'].append("ConfigFile is searched in the following order:")
            log_msgs['info'].append("1. cmd line: -c/--configfile/--configFile /path/to/myconfig.yml")
            log_msgs['info'].append("2. local dir: ./config.yml")
            log_msgs['info'].append("3. ENV(AQMS_DB_CONFIG) --> points to config file (e.g., >export AQMS_DB_CONFIG=/path/to/config.yml")
            log_msgs['info'].append("4. PKG INSALLATION DIR:%s" % INSTALL_DIR)
            #print()
            #exit(2)

    return None, log_msgs


import argparse
def pick_off_configFile(argv, debug=False):

    parser = argparse.ArgumentParser(add_help=False)
    optional = parser._action_groups.pop()
    #required = parser.add_argument_group("required arguments")
    parser._action_groups.append(optional) #.
    optional.add_argument('--configFile', '--configfile', '-c', type=str, metavar='// --configfile config.yml')
    #optional.add_argument('--configFile', type=str, metavar='--configFile config.yml')
    #optional.add_argument('--configfile', type=str, metavar='--configfile config.yml')
    #optional.add_argument('-c', type=str, metavar='-c config.yml')

    args, unknown = parser.parse_known_args()

    found = False
    index = 0
    if args.configFile:
        if debug:
            print("pick_off_configFile --> args.configFile=%s passed in" % args.configFile)

        return args.configFile

    return None

        #if not os.path.exists(args.configFile):
            #print("ERROR: configfile=[%s] does not exist --> Exitting!" % args.configFile)
            #exit(2)


def parse_config(filename=None):
    """
        Read in config from yaml filename
    """
    configuration = {}
    '''
    if not os.path.exists(filename):
        print("configFile=[%s] does not exist --> Exit" % filename)
        logger.error("configFile=[%s] does not exist --> Exit" % filename)
        exit(2)
    '''

    try:
        with open(filename, 'r') as ymlfile:
            configuration = yaml.load(ymlfile, Loader=yaml.FullLoader)
    except FileNotFoundError as e:
        return None, e
        #return None, "Error trying to read filename:%s: %s" % (filename, e)

    return configuration, None

