from __future__ import annotations

import asyncio
from asyncio import Future
from typing import AsyncIterable, AsyncIterator, TypeAlias, TypeVar

import wrapt

T = TypeVar("T")

ItemAndNextFuture: TypeAlias = Future[tuple[T, "ItemAndNextFuture[T]"]]


async def _cloned_aiter(future: ItemAndNextFuture[T]) -> AsyncIterator[T]:
    """Helper function for `clone_async_iterator`."""
    while True:
        try:
            item, future = await future
            yield item
        except asyncio.CancelledError:
            return


def tee_async_iterable(source: AsyncIterable[T], n_clones: int) -> tuple[AsyncIterator[T], ...]:
    """Create n clones of an async iterable, each receiving every item generated by the source.

    Note that this is not a true copy, as the source iterable is not duplicated. Instead, each
    copy is a separate iterator that receives the same items from the source iterable. The elements
    are not copied, so if a list is yielded from the source iterable, each copy will receive the
    same list object.

    The original iterable should not be iterated over after the copies are created, as this will
    cause the copies to miss items.

    Objects yielded from the source iterable will also stay in memory until all copies have
    finished iterating over them. This can cause memory issues in a long-running program if the
    copied async iterators are not consumed at the same rate as the source iterable.
      Todo - Perhaps use weak references to allow the source iterable to be garbage collected

    Args:
        source: The source iterable to copy.
        n_clones: The number of copies to create.

    Returns:
        A tuple of async iterators, each receiving the same items from the source iterable.
    """
    futures = [ItemAndNextFuture[T]() for _ in range(n_clones)]

    async def _copier() -> None:
        futs = futures

        async for item in source:

            new_futs: list[ItemAndNextFuture[T]] = []
            for fut in futs:
                next_fut = ItemAndNextFuture[T]()
                new_futs.append(next_fut)
                fut.set_result((item, next_fut))
            futs = new_futs

        for fut in futs:
            fut.cancel(StopAsyncIteration)

    asyncio.create_task(_copier())
    copied = tuple(_cloned_aiter(fut) for fut in futures)
    return copied


atee = tee_async_iterable


class ClonableAsyncIterableWrapper(AsyncIterable[T], wrapt.ObjectProxy):  # noqa
    def __init__(self, source: AsyncIterable[T]):
        super().__init__(source)
        self._self_source, self._self_clone = tee_async_iterable(source, 2)

    def aclone(self) -> AsyncIterator[T]:
        """Create a clone of this async iterable.

        Returns:
            An async iterator, each receiving the same items from the source iterable.
        """
        self._self_clone, clone = tee_async_iterable(self._self_clone, 2)
        return clone

    def __aiter__(self) -> AsyncIterator[T]:
        return self._self_source.__aiter__()

    async def __anext__(self) -> T:
        return await self._self_source.__anext__()


if __name__ == "__main__":
    import asyncio
    import random

    from asyncutils.amerge import amerge

    async def main() -> None:
        async def source() -> AsyncIterator[int]:
            for i in range(10):
                await asyncio.sleep(random.random() / 10)
                yield random.randint(0, 100)

        a, b = tee_async_iterable(source(), 2)
        async for i in amerge(a, b):
            print(i)

        it = ClonableAsyncIterableWrapper(source())
        a = it.aclone()
        b = it.aclone()

        async for i in amerge(a, b, it):
            print(i)

    asyncio.run(main())

"""
The Python __index__ method is used to convert an object to an integer. 
It is called when an object is used in a context where an integer is required, such as 
when indexing a sequence or slicing a sequence.
"""
