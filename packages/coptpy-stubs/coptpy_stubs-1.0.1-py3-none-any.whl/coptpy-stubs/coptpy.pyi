# Copyright 2022, Cardinal Operations

from types import TracebackType
from typing import (
    Any,
    Callable,
    Dict,
    Generator,
    List,
    Iterable,
    Mapping,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload
)
from scipy import sparse
import numpy as np

_T = TypeVar('_T')
_U = TypeVar('_U')
_Scalar = Union[int, float, str]
_LinExprLike = Union[float, Var, ExprBuilder, LinExpr]
_PsdExprLike = Union[float, Var, ExprBuilder, LinExpr, PsdExpr, PsdVar]
_QuadExprLike = Union[float, Var, ExprBuilder, LinExpr, QuadExpr]
_ModelComponent = Union[Cone, Var, PsdVar, Constraint, QConstraint, PsdConstraint, GenConstr, SOS]

@overload
def multidict(
    __data: Mapping[_T, float]
) -> Tuple[tuplelist[_T], tupledict[_T, float]]: ...
@overload
def multidict(
    __data: Mapping[Any, Iterable[float]]
) -> Tuple[Any, ...]: ...
@overload
def multidict(
    __data: Iterable[Tuple[Any, Iterable[float]]]
) -> Tuple[Any, ...]: ...

@overload
def quicksum(termlist: Mapping[Any, Var]) -> LinExpr: ...
@overload
def quicksum(termlist: Iterable[_LinExprLike]) -> LinExpr: ...
@overload
def quicksum(termlist: Iterable[_QuadExprLike]) -> QuadExpr: ...

@overload
def psdquicksum(termlist: Mapping[Any, PsdVar]) -> PsdExpr: ...
@overload
def psdquicksum(termlist: Iterable[_LinExprLike]) -> LinExpr: ...
@overload
def psdquicksum(termlist: Iterable[_PsdExprLike]) -> PsdExpr: ...

class ILogCallback: ...
class LogCallback(ILogCallback):
    def __init__(self) -> None: ...
    def Display(self, msg: str) -> None: ...

class ParamEnum:
    # Double parameters
    TimeLimit: str = ...
    MatrixTol: str = ...
    FeasTol: str = ...
    DualTol: str = ...
    IntTol: str = ...
    RelGap: str = ...
    AbsGap: str = ...
    TuneTimeLimit: str = ...
    TuneTargetLimit: str = ...
    TuenTargetRelGap: str = ...

    # Integer parameters
    Logging: str = ...
    LogToConsole: str = ...
    Presolve: str = ...
    Scaling: str = ...
    Dualize: str = ...
    LpMethod: str = ...
    ReqFarkasRay: str = ...
    DualPrice: str = ...
    DualPerturb: str = ...
    CutLevel: str = ...
    RootCutLevel: str = ...
    TreeCutLevel: str = ...
    RootCutRounds: str = ...
    NodeCutRounds: str = ...
    HeurLevel: str = ...
    RoundingHeurLevel: str = ...
    DivingHeurLevel: str = ...
    SubMipHeurLevel: str = ...
    StrongBranching: str = ...
    ConflictAnalysis: str = ...
    NodeLimit: str = ...
    MipTasks: str = ...
    BarHomogeneous: str = ...
    BarOrder: str = ...
    BarIterLimit: str = ...
    Threads: str = ...
    BarThreads: str = ...
    SimplexThreads: str = ...
    CrossoverThreads: str = ...
    Crossover: str = ...
    SDPMethod: str = ...
    IISMethod: str = ...
    FeasRelaxMode: str = ...
    MipStartMode: str = ...
    MipStartNodeLimit: str = ...
    TuneMethod: str = ...
    TuneMode: str = ...
    TuneMeasure: str = ...
    TunePermutes: str = ...
    TuneOutputLevel: str = ...

class AttrEnum:
    # Double attributes
    SolvingTime: str = ...
    ObjConst: str = ...
    LpObjVal: str = ...
    BestObj: str = ...
    BestBnd: str = ...
    BestGap: str = ...
    FeasRelaxObj: str = ...

    # Integer attributes
    Cols: str = ...
    PsdCols: str = ...
    Rows: str = ...
    Elems: str = ...
    QElems: str = ...
    PsdElems: str = ...
    SymMats: str = ...
    Bins: str = ...
    Ints: str = ...
    Soss: str = ...
    Cones: str = ...
    QConstrs: str = ...
    PsdConstrs: str = ...
    Indicators: str = ...
    IISCols: str = ...
    IISRows: str = ...
    IISSOSs: str = ...
    IISIndicators: str = ...
    ObjSense: str = ...
    LpStatus: str = ...
    MipStatus: str = ...
    SimplexIter: str = ...
    BarrierIter: str = ...
    NodeCnt: str = ...
    PoolSols: str = ...
    TuneResults: str = ...
    HasLpSol: str = ...
    HasDualFarkas: str = ...
    HasPrimalRay: str = ...
    HasBasis: str = ...
    HasMipSol: str = ...
    HasQObj: str = ...
    HasPsdObj: str = ...
    HasIIS: str = ...
    HasFeasRelaxSol: str = ...
    IsMIP: str = ...
    IsMinIIS: str = ...

class InfoEnum:
    # Double information
    Obj: str = ...
    LB: str = ...
    UB: str = ...
    Value: str = ...
    Slack: str = ...
    Dual: str = ...
    RedCost: str = ...
    DualFarkas: str = ...
    PrimalRay: str = ...
    RelaxLB: str = ...
    RelaxUB: str = ...
    RelaxValue: str = ...

class COPT:
    # Version numbers
    VERSION_MAJOR: int = ...
    VERSION_MINOR: int = ...
    VERSION_TECHNICAL: int = ...

    # Optimization directions
    MINIMIZE: int = ...
    MAXIMIZE: int = ...

    # Infinity value
    INFINITY: float = ...
    # Undefined value
    UNDEFINED: float = ...

    # Constraint types
    LESS_EQUAL: str = ...
    GREATER_EQUAL: str = ...
    EQUAL: str = ...
    FREE: str = ...
    RANGE: str = ...

    # Variable types
    CONTINUOUS: str = ...
    BINARY: str = ...
    INTEGER: str = ...

    # SOS-variable types
    SOS_TYPE1: int = ...
    SOS_TYPE2: int = ...

    # Cone types
    CONE_QUAD: int = ...
    CONE_RQUAD: int = ...

    # Basis status
    BASIS_LOWER: int = ...
    BASIS_BASIC: int = ...
    BASIS_UPPER: int = ...
    BASIS_SUPERBASIC: int = ...
    BASIS_FIXED: int = ...

    # Optimization status
    UNSTARTED: int = ...
    OPTIMAL: int = ...
    INFEASIBLE: int = ...
    UNBOUNDED: int = ...
    INF_OR_UNB: int = ...
    NUMERICAL: int = ...
    NODELIMIT: int = ...
    TIMEOUT: int = ...
    UNFINISHED: int = ...
    INTERRUPTED: int = ...

    # Envr config keywords
    CLIENT_CLUSTER: str = ...
    CLIENT_FLOATING: str = ...
    CLIENT_PASSWORD: str = ...
    CLIENT_PORT: str = ...
    CLIENT_WAITTIME: str = ...

    Param: ParamEnum = ...
    param: ParamEnum = ...
    Attr: AttrEnum = ...
    attr: AttrEnum = ...
    Info: InfoEnum = ...
    info: InfoEnum = ...

class CoptError(Exception):
    retcode: int = ...
    message: str = ...
    def __init__(self, retcode: int = 0, message: str = "") -> None: ...

class ParamSetting:
    def __init__(self, model: Model) -> None: ...
    def __getattr__(self, paramname: str) -> Union[int, float]: ...
    def __setattr__(self, paramname: str, newval: _Scalar) -> None: ...

class SOS:
    # mutable info or params
    iis: int = ...

    def getIdx(self) -> int: ...
    def setIIS(self) -> int: ...
    def remove(self) -> None: ...

    # read-only info or attributes
    @property
    def index(self) -> int: ...

class SOSArray:
    def __init__(
        self,
        soss: Optional[Union[SOS, Iterable[SOS], Mapping[Any, SOS]]] = None
        )-> None: ...
    def __getitem__(self, idx: int) -> SOS: ...
    def __iter__(self) -> SOSArray: ...
    def __next__(self) -> SOS: ...
    def pushBack(self, sos: Union[SOS, Iterable[SOS], Mapping[Any, SOS]]) -> None: ...
    def getSOS(self, idx: _Scalar) -> SOS: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class SOSBuilder:
    def __init__(self) -> None: ...
    @overload
    def setBuilder(
        self,
        sostype: int,
        vars: Union[Var, VarArray, Iterable[Var]],
        weights: Optional[Iterable[float]] = None
        ) -> None: ...
    @overload
    def setBuilder(
        self,
        sostype: int,
        vars: Mapping[_T, Var],
        weights: Optional[Mapping[_T, float]] = None
        ) -> None: ...
    def getType(self) -> int: ...
    def getVar(self, idx: _Scalar) -> Var: ...
    def getVars(self, idx: Optional[Iterable[int]]) -> VarArray: ...
    def getWeight(self, idx: _Scalar) -> float: ...
    def getWeights(self, idx: Optional[Iterable[int]]) -> List[float]: ...
    def getSize(self) -> int: ...

    # read-only info or attributes
    @property
    def type(self) -> int: ...
    @property
    def vars(self) -> VarArray: ...
    @property
    def weights(self) -> List[float]: ...
    @property
    def size(self) -> int: ...

class SOSBuilderArray:
    def __init__(
        self,
        sosbuilders: Optional[Union[SOSBuilder, Iterable[SOSBuilder], Mapping[Any, SOSBuilder]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> SOSBuilder: ...
    def __iter__(self) -> SOSBuilderArray: ...
    def __next__(self) -> SOSBuilder: ...
    def pushBack(
        self,
        sosbuilder: Union[SOSBuilder, Iterable[SOSBuilder], Mapping[Any, SOSBuilder]]
        ) -> None: ...
    def getBuilder(self, idx: _Scalar) -> SOSBuilder: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class Cone:
    def __getattr__(self, attrname: str)-> int: ...
    def getIdx(self) -> int: ...
    def remove(self) -> None: ...

    # read-only info or attributes
    @property
    def index(self) -> int: ...

class ConeArray:
    def __init__(
        self,
        cones: Optional[Union[Cone, Iterable[Cone], Mapping[Any, Cone]]]
        ) -> None: ...
    def __getitem__(self, idx: int) -> Cone: ...
    def __iter__(self) -> ConeArray: ...
    def __next__(self) -> Cone: ...
    def pushBack(self, cone: Union[Cone, Iterable[Cone], Mapping[Any, Cone]]) -> None: ...
    def getCone(self, idx: _Scalar) -> Cone: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class ConeBuilder:
    def __init__(self) -> None: ...
    def setBuilder(
        self,
        conetype: int,
        vars: Union[Var, VarArray, Iterable[Var], Mapping[Any, Var]]
        ) -> None: ...
    def getType(self) -> int: ...
    def getVar(self, idx: _Scalar) -> Var: ...
    def getVars(self, idx: Optional[Iterable[int]] = None) -> VarArray: ...
    def getSize(self) -> int: ...

    # read-only info or attributes
    @property
    def type(self) -> int: ...
    @property
    def vars(self) -> VarArray: ...
    @property
    def size(self) -> int: ...

class ConeBuilderArray:
    def __init__(
        self,
        conebuilders: Optional[Union[ConeBuilder, Iterable[ConeBuilder], Mapping[Any, ConeBuilder]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> ConeBuilder: ...
    def __iter__(self) -> ConeBuilderArray: ...
    def __next__(self) -> ConeBuilder: ...
    def pushBack(
        self,
        conebuilder: Union[ConeBuilder, Iterable[ConeBuilder], Mapping[Any, ConeBuilder]]
        ) -> None: ...
    def getBuilder(self, idx: _Scalar) -> ConeBuilder: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class Var:
    # mutable info or params
    # TODO: add more if needed
    lb: float = ...
    LB: float = ...
    name: str = ...
    ub: float = ...
    UB: float = ...
    vtype: str = ...
    VType: str = ...

    def getType(self) -> str: ...
    def getName(self) -> str: ...
    def getBasis(self) -> int: ...
    def getLowerIIS(self) -> float: ...
    def getUpperIIS(self) -> float: ...
    def getIdx(self) -> int: ...
    def setType(self, newtype: str) -> None: ...
    def setName(self, newname: str) -> None: ...
    def getInfo(self, infoname: str) -> float: ...
    def setInfo(self, infoname: str, newval: float) -> None: ...
    def remove(self) -> None: ...

    # read-only info or attributes
    # TODO: add more if needed
    @property
    def basis(self) -> int: ...
    @property
    def index(self) -> int: ...
    @property
    def x(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def rc(self) -> float: ...
    @property
    def iislb(self) -> float: ...
    @property
    def iisub(self) -> float: ...
    @property
    def relaxlb(self) -> float: ...
    @property
    def relaxub(self) -> float: ...
    @property
    def size(self) -> int: ...
    @property
    def shape(self) -> int: ...

    @overload
    def __add__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __add__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __add__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __add__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __radd__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __radd__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __radd__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __radd__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __sub__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __sub__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __sub__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __sub__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __rsub__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __rsub__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __rsub__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __rsub__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __mul__(self, other: float) -> ExprBuilder: ...
    @overload
    def __mul__(self, other: Union[Var, ExprBuilder, LinExpr]) -> QuadExpr: ...
    @overload
    def __rmul__(self, other: float) -> ExprBuilder: ...
    @overload
    def __rmul__(self, other: Union[Var, ExprBuilder, LinExpr]) -> QuadExpr: ...
    def __pow__(self, other: int) -> QuadExpr: ...
    def __truediv__(self, other: float) -> ExprBuilder: ...
    def __neg__(self) -> ExprBuilder: ...
    # '==', '<=' and '>=' are used as constraint sense
    @overload
    def __eq__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __eq__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __eq__(self, other: PsdExpr) -> PsdConstrBuilder: ...
    @overload
    def __le__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __le__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __le__(self, other: PsdExpr) -> PsdConstrBuilder: ...
    @overload
    def __ge__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __ge__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __ge__(self, other: PsdExpr) -> PsdConstrBuilder: ...

class VarArray:
    def __init__(
        self,
        vars: Optional[Union[Var, Iterable[Var], Mapping[Any, Var]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> Var: ...
    def __iter__(self) -> VarArray: ...
    def __next__(self) -> Var: ...
    def pushBack(self, var: Union[Var, Iterable[Var], Mapping[Any, Var]]) -> None: ...
    def getVar(self, idx: int) -> Var: ...
    def getAll(self) -> List[Var]: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class PsdVar:
    name: str = ...
    def getName(self) -> str: ...
    def getIdx(self) -> int: ...
    def getDim(self) -> int: ...
    def getLen(self) -> int: ...
    def setName(self, newname: str) -> None: ...
    def getInfo(self, infoname: str) -> List[float]: ...
    def remove(self) -> None: ...

    @property
    def x(self) -> List[float]: ...
    @property
    def dual(self) -> List[float]: ...
    @property
    def rc(self) -> List[float]: ...
    @property
    def dim(self) -> int: ...
    @property
    def len(self) -> int: ...
    @property
    def index(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def shape(self) -> int: ...

    @overload
    def __mul__(self, mat: SymMatrix) -> PsdExpr: ...
    @overload
    def __mul__(self, mat: SymMatExpr) -> PsdExpr: ...
    @overload
    def __rmul__(self, mat: SymMatrix) -> PsdExpr: ...
    @overload
    def __rmul__(self, mat: SymMatExpr) -> PsdExpr: ...

class PsdVarArray:
    def __init__(
        self,
        vars: Optional[Union[PsdVar, Iterable[PsdVar], Mapping[Any, PsdVar]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> PsdVar: ...
    def __iter__(self) -> PsdVarArray: ...
    def __next__(self) -> PsdVar: ...
    def pushBack(self, var: Union[PsdVar, Iterable[PsdVar], Mapping[Any, PsdVar]]) -> None: ...
    def getPsdVar(self, idx: int) -> PsdVar: ...
    def getSize(self) -> int: ...
    def reserve(self, n: int) -> None: ...
    @property
    def size(self) -> int: ...

class SymMatExpr:
    def __init__(self, expr: SymMatrix = None) -> None: ...
    def setCoeff(self, idx: int, val: float) -> None: ...
    def getCoeff(self, idx: int) -> float: ...
    def getSymMat(self, idx: int) -> SymMatrix: ...
    def getDim(self) -> int: ...
    def getSize(self) -> int: ...
    def addTerm(self, mat: SymMatrix, coeff: float = 1.0) -> None: ...
    def addTerms(
        self,
        mats: Union[SymMatrix, SymMatrixArray, Iterable[SymMatrix], Mapping[Any, SymMatrix]],
        coeffs: Union[float, Sequence[float]]
        ) -> None: ...
    def addSymMatExpr(self, expr: SymMatExpr, mult: float = 1.0) -> None: ...
    def clone(self) -> None: ...
    def reserve(self, n: int) -> None: ...
    def remove(self, item: Union[int, SymMatrix]) -> None: ...
    @property
    def size(self) -> int: ...
    @property
    def dim(self) -> int: ...

    def __add__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __radd__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __iadd__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __sub__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __rsub__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __isub__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    @overload
    def __mul__(self, other: float) -> SymMatExpr: ...
    @overload
    def __mul__(self, other: PsdVar) -> PsdExpr: ...
    @overload
    def __rmul__(self, other: float) -> SymMatExpr: ...
    @overload
    def __rmul__(self, other: PsdVar) -> PsdExpr: ...
    def __imul__(self, other: float) -> SymMatExpr: ...
    def __truediv__(self, other: float) -> SymMatExpr: ...
    def __itruediv__(self, other: float) -> SymMatExpr: ...
    def __neg__(self) -> SymMatExpr: ...
    
class SymMatrix:
    def getIdx(self) -> int: ...
    def getDim(self) -> int: ...
    @property
    def index(self) -> int: ...
    def dim(self) -> int: ...
    def size(self) -> Tuple[int, int]: ...
    def shape(self) -> Tuple[int, int]: ...

    def __add__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __radd__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __sub__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    def __rsub__(self, other: Union[SymMatrix, SymMatExpr]) -> SymMatExpr: ...
    @overload
    def __mul__(self, other: float) -> SymMatExpr: ...
    @overload
    def __mul__(self, other: PsdVar) -> PsdExpr: ...
    @overload
    def __rmul__(self, other: float) -> SymMatExpr: ...
    @overload
    def __rmul__(self, other: PsdVar) -> PsdExpr: ...
    def __truediv__(self, other: float) -> SymMatExpr: ...
    def __neg__(self) -> SymMatExpr: ...

class SymMatrixArray:
    def __init__(
        self,
        mats: Optional[Union[SymMatrix, Iterable[SymMatrix], Mapping[Any, SymMatrix]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> SymMatrix: ...
    def __iter__(self) -> SymMatrixArray: ...
    def __next__(self) -> SymMatrix: ...
    def pushBack(self, mat: Union[SymMatrix, Iterable[SymMatrix], Mapping[Any, SymMatrix]]) -> None: ...
    def getMatrix(self, idx: int) -> SymMatrix: ...
    def getSize(self) -> int: ...
    def reserve(self, n: int) -> None: ...
    @property
    def size(self) -> int: ...

class Constraint:
    # mutable info or params
    # TODO: add more if needed
    name: str = ...

    def getName(self) -> str: ...
    def getBasis(self) -> int: ...
    def getLowerIIS(self) -> float: ...
    def getUpperIIS(self) -> float: ...
    def getIdx(self) -> int: ...
    def setName(self, newname: str) -> None: ...
    def getInfo(self, infoname: str) -> float: ...
    def setInfo(self, infoname: str, newval: float) -> None: ...
    def remove(self) -> None: ...

    # read-only info or attributes 
    # TODO: add more if needed
    @property
    def basis(self) -> int: ...
    @property
    def index(self) -> int: ...
    @property
    def pi(self) -> float: ...
    @property
    def iislb(self) -> float: ...
    @property
    def iisub(self) -> float: ...
    @property
    def relaxlb(self) -> float: ...
    @property
    def relaxub(self) -> float: ...

class ConstrArray:
    def __init__(
        self,
        constrs: Optional[Union[Constraint, Iterable[Constraint], Mapping[Any, Constraint]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> Constraint: ...
    def __iter__(self) -> ConstrArray: ...
    def __next__(self) -> Constraint: ...
    def pushBack(self, constr: Union[Constraint, Iterable[Constraint], Mapping[Any, Constraint]]) -> None: ...
    def getConstr(self, idx: int) -> Constraint: ...
    def getAll(self) -> List[Constraint]: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class ConstrBuilder:
    def __init__(self) -> None: ...
    def setBuilder(
        self,
        expr: _LinExprLike,
        sense: str,
        rhs: float
        ) -> None: ...
    def getExpr(self) -> LinExpr: ...
    def getSense(self) -> str: ...

    def __rshift__(self, other: ConstrBuilder) -> GenConstrBuilder: ...

class ConstrBuilderArray:
    def __init__(
        self,
        constrs: Optional[Union[ConstrBuilder, Iterable[ConstrBuilder], Mapping[Any, ConstrBuilder]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> ConstrBuilder: ...
    def __iter__(self) -> ConstrBuilderArray: ...
    def __next__(self) -> ConstrBuilder: ...
    def pushBack(self, constrbuilder: Union[ConstrBuilder, Iterable[ConstrBuilder], Mapping[Any, ConstrBuilder]]) -> None: ...
    def getBuilder(self, idx: int) -> ConstrBuilder: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class GenConstr:
    def getIdx(self) -> int: ...
    def getIIS(self) -> int: ...
    def remove(self) -> None: ...

    # read-only info or attributes 
    @property
    def index(self) -> int: ...
    @property
    def iis(self) -> int: ...

class GenConstrArray:
    def __init__(
        self,
        constrs: Optional[Union[GenConstr, Iterable[GenConstr], Mapping[Any, GenConstr]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> GenConstr: ...
    def __iter__(self) -> GenConstrArray: ...
    def __next__(self) -> GenConstr: ...
    def pushBack(self, genconstr: Union[GenConstr, Iterable[GenConstr], Mapping[Any, GenConstr]]) -> None: ...
    def getGenConstr(self, idx: int) -> GenConstr: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class GenConstrBuilder:
    def __init__(self) -> None: ...
    def setBuilder(
        self,
        var: Var,
        val: int,
        expr: _LinExprLike,
        sense: str
        ) -> None: ...
    def getBinVar(self) -> Var: ...
    def getBinVal(self) -> int: ...
    def getExpr(self) -> LinExpr: ...
    def getSense(self) -> str: ...

    # read-only info or attributes 
    @property
    def binvar(self) -> Var: ...
    @property
    def binval(self) -> int: ...
    @property
    def expr(self) -> LinExpr: ...
    @property
    def sense(self) -> str: ...

class GenConstrBuilderArray:
    def __init__(
        self,
        constrs: Optional[Union[GenConstrBuilder, Iterable[GenConstrBuilder], Mapping[Any, GenConstrBuilder]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> GenConstrBuilder: ...
    def __iter__(self) -> GenConstrBuilderArray: ...
    def __next__(self) -> GenConstrBuilder: ...
    def pushBack(self, genconstrbuilder: Union[GenConstrBuilder, Iterable[GenConstrBuilder], Mapping[Any, GenConstrBuilder]]) -> None: ...
    def getBuilder(self, idx: int) -> GenConstrBuilder: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class QConstraint:
    name: str = ...
    rhs: float = ...
    sense: str = ...
    def getName(self) -> str: ...
    def getIdx(self) -> int: ...
    def setName(self, newname: str) -> None: ...
    def getRhs(self) -> float: ...
    def getSense(self) -> str: ...
    def setRhs(self, rhs: float) -> None: ...
    def setSense(self, sense: str) -> None: ...
    def getInfo(self, infoname: str) -> float: ...
    def setInfo(self, infoname: str, newval: float) -> None: ...
    def remove(self) -> None: ...

class QConstrArray:
    def __init__(
        self,
        constrs: Optional[Union[QConstraint, Iterable[QConstraint], Mapping[Any, QConstraint]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> QConstraint: ...
    def __iter__(self) -> QConstrArray: ...
    def __next__(self) -> QConstraint: ...
    def pushBack(self, qconstrs: Union[QConstraint, Iterable[QConstraint], Mapping[Any, QConstraint]]) -> None: ...
    def getQConstr(self, idx: int) -> QConstraint: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class QConstrBuilder:
    def __init__(self) -> None: ...
    def setBuilder(
        self,
        expr: _QuadExprLike,
        sense: str,
        rhs: float
        ) -> None: ...
    def getQuadExpr(self) -> QuadExpr: ...
    def getSense(self) -> str: ...

class QConstrBuilderArray:
    def __init__(
        self,
        constrs: Optional[Union[QConstrBuilder, Iterable[QConstrBuilder], Mapping[Any, QConstrBuilder]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> QConstrBuilder: ...
    def __iter__(self) -> QConstrBuilderArray: ...
    def __next__(self) -> QConstrBuilder: ...
    def pushBack(self, qconstrbuilder: Union[QConstrBuilder, Iterable[QConstrBuilder], Mapping[Any, QConstrBuilder]]) -> None: ...
    def getBuilder(self, idx: int) -> QConstrBuilder: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class PsdConstraint: 
    # mutable info or params
    name: str = ...

    def getName(self) -> str: ...
    def getIdx(self) -> int: ...
    def setName(self, newname: str) -> None: ...
    def getInfo(self, infoname: str) -> float: ...
    def setInfo(self, infoname: str, newval: float) -> None: ...
    def remove(self) -> None: ...

    # read-only info or attributes 
    @property
    def index(self) -> int: ...

class PsdConstrArray: 
    def __init__(
        self,
        constrs: Optional[Union[PsdConstraint, Iterable[PsdConstraint], Mapping[Any, PsdConstraint]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> PsdConstraint: ...
    def __iter__(self) -> PsdConstrArray: ...
    def __next__(self) -> PsdConstraint: ...
    def pushBack(self, constrs: Union[PsdConstraint, Iterable[PsdConstraint], Mapping[Any, PsdConstraint]]) -> None: ...
    def getPsdConstr(self, idx: int) -> PsdConstraint: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class PsdConstrBuilder:
    def __init__(self) -> None: ...
    def setBuilder(
        self,
        expr: _PsdExprLike,
        sense: str,
        rhs: float
        ) -> None: ...
    def setRange(self, expr: _PsdExprLike, range: float) -> None: ...
    def getPsdExpr(self) -> PsdExpr: ...
    def getSense(self) -> str: ...
    def getRange(self) -> float: ...

class PsdConstrBuilderArray: 
    def __init__(
        self,
        constrs: Optional[Union[PsdConstrBuilder, Iterable[PsdConstrBuilder], Mapping[Any, PsdConstrBuilder]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> PsdConstrBuilder: ...
    def __iter__(self) -> PsdConstrBuilderArray: ...
    def __next__(self) -> PsdConstrBuilder: ...
    def pushBack(self, builder: Union[PsdConstrBuilder, Iterable[PsdConstrBuilder], Mapping[Any, PsdConstrBuilder]]) -> None: ...
    def getBuilder(self, idx: int) -> PsdConstrBuilder: ...
    def getSize(self) -> int: ...
    @property
    def size(self) -> int: ...

class Column: 
    @overload
    def __init__(
        self,
        constrs: Union[Constraint, Column],
        coeffs: Optional[float] = None
        ) -> None: ...
    @overload
    def __init__(
        self,
        constrs: Union[ConstrArray, Iterable[Constraint]],
        coeffs: Union[float, Sequence[float]]
        ) -> None: ...
    @overload
    def __init__(
        self,
        constrs: Mapping[_T, Constraint],
        coeffs: Union[float, Mapping[_T, float]]
        ) -> None: ...
    @overload
    def __init__(
        self,
        constrs: Iterable[tuple[Constraint, float]],
        ) -> None: ... 
    @overload
    def __init__(self) -> None: ...
    def setCoeff(self, idx: int, newval: float) -> None: ...
    def getCoeff(self, idx: int) -> float: ...
    def getConstr(self, idx: int) -> Constraint: ...
    def getSize(self) -> int: ...
    def addTerm(self, constr: Constraint, coeff: float = 1.0) -> None: ...
    @overload
    def addTerms(
        self,
        constrs: Union[Constraint, ConstrArray, Iterable[Constraint]],
        coeffs: Union[float, Sequence[float]]
        ) -> None: ...
    @overload
    def addTerms(
        self,
        constrs: Mapping[_T, Constraint],
        coeffs: Union[float, Mapping[_T, float]]
        ) -> None: ...
    def addColumn(self, col: Column, mult: float = 1.0) -> None: ...
    def clone(self) -> LinExpr: ...
    def remove(self, item: Union[int, Constraint]) -> None: ...
    def clear(self) -> None: ...
    @property
    def size(self) -> int: ...

class ColumnArray:
    def __init__(
        self,
        constrs: Optional[Union[Column, Iterable[Column], Mapping[Any, Column]]] = None
        ) -> None: ...
    def __getitem__(self, idx: int) -> Column: ...
    def __iter__(self) -> ColumnArray: ...
    def __next__(self) -> Column: ...
    def pushBack(self, column: Union[Column, Iterable[Column], Mapping[Any, Column]]) -> None: ...
    def getColumn(self, idx: int) -> Column: ...
    def getSize(self) -> int: ...
    def clear(self) -> None: ...
    @property
    def size(self) -> int: ...

class ExprBuilder: 
    @overload
    def __init__(
        self,
        arg1: Union[Var, ExprBuilder, Iterable[Var]],
        arg2: Optional[Union[_Scalar, Iterable[_Scalar]]] = None
        ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: _Scalar = 0.0
    ) -> None: ...
    def getSize(self) -> int: ...
    def getCoeff(self, idx: int) -> float: ...
    def getVar(self, idx: int) -> Var: ...
    def getConstant(self) -> float: ...
    def addTerm(self, var: Var, coeff: float = 1.0) -> None: ...
    def addExpr(self, expr: ExprBuilder, mult: float = 1.0) -> None: ...
    def clone(self) -> ExprBuilder: ...
    def getExpr(self) -> LinExpr: ...
    @property
    def size(self) -> int: ...

    @overload
    def __add__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __add__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __add__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __add__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __radd__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __radd__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __radd__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __radd__(self, other: PsdExpr) -> PsdExpr: ...
    def __iadd__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __sub__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __sub__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __sub__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __sub__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __rsub__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __rsub__(self, other: LinExpr) -> LinExpr: ...
    @overload
    def __rsub__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __rsub__(self, other: PsdExpr) -> PsdExpr: ...
    def __isub__(self, other: Union[float, Var, ExprBuilder]) -> ExprBuilder: ...
    @overload
    def __mul__(self, other: float) -> ExprBuilder: ...
    @overload
    def __mul__(self, other: Union[Var, ExprBuilder, LinExpr]) -> QuadExpr: ...
    @overload
    def __rmul__(self, other: float) -> ExprBuilder: ...
    @overload
    def __rmul__(self, other: Union[Var, ExprBuilder, LinExpr]) -> QuadExpr: ...
    def __imul__(self, other: float) -> ExprBuilder: ...
    def __pow__(self, other: int) -> QuadExpr: ...
    def __truediv__(self, other: float) -> ExprBuilder: ...
    def __div__(self, other: float) -> ExprBuilder: ...
    def __neg__(self) -> ExprBuilder: ...
    # '==', '<=' and '>=' are used as constraint sense
    @overload
    def __eq__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __eq__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __eq__(self, other: PsdExpr) -> PsdConstrBuilder: ...
    @overload
    def __le__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __le__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __le__(self, other: PsdExpr) -> PsdConstrBuilder: ...
    @overload
    def __ge__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __ge__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __ge__(self, other: PsdExpr) -> PsdConstrBuilder: ...

class LinExpr:
    # mutable info or params
    constant: float = ...

    @overload
    def __init__(
        self,
        arg1: Union[Var, ExprBuilder, LinExpr],
        arg2: Optional[float] = None
        ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: Union[VarArray, Iterable[Var]],
        arg2: Union[float, Sequence[float]]
        ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: Mapping[_T, Var],
        arg2: Union[float, Mapping[_T, float]]
        ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: Iterable[tuple[Var, float]],
        ) -> None: ... 
    @overload
    def __init__(
        self,
        arg1: _Scalar = 0.0
        ) -> None: ...
    def setCoeff(self, idx: int, newval: float) -> None: ...
    def getCoeff(self, idx: int) -> float: ...
    def getVar(self, idx: int) -> Var: ...
    def getConstant(self) -> float: ...
    def getValue(self) -> float: ...
    def getSize(self) -> int: ...
    def setConstant(self, newval: float) -> None: ...
    def addConstant(self, newval: float) -> None: ...
    def addTerm(self, var: Var, coeff: float = 1.0) -> None: ...
    @overload
    def addTerms(
        self,
        vars: Union[Var, VarArray, Iterable[Var]],
        coeffs: Union[float, Sequence[float]]
        ) -> None: ...
    @overload
    def addTerms(
        self,
        vars: Mapping[_T, Var],
        coeffs: Union[float, Mapping[_T, float]]
        ) -> None: ...
    def addExpr(self, expr: Union[ExprBuilder, LinExpr], mult: float = 1.0) -> None: ...
    def clone(self) -> LinExpr: ...
    def reserve(self, n: int) -> None: ...
    def remove(self, item: Union[int, Var]) -> None: ...

    # read-only info or attributes 
    @property
    def value(self) -> float: ...
    @property
    def size(self) -> int: ...

    @overload
    def __add__(self, other: Union[float, Var, ExprBuilder, LinExpr]) -> LinExpr: ...
    @overload
    def __add__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __add__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __radd__(self, other: Union[float, Var, ExprBuilder, LinExpr]) -> LinExpr: ...
    @overload
    def __radd__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __radd__(self, other: PsdExpr) -> PsdExpr: ...
    def __iadd__(self, other: Union[float, Var, ExprBuilder, LinExpr]) -> LinExpr: ...
    @overload
    def __sub__(self, other: Union[float, Var, ExprBuilder, LinExpr]) -> LinExpr: ...
    @overload
    def __sub__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __sub__(self, other: PsdExpr) -> PsdExpr: ...
    @overload
    def __rsub__(self, other: Union[float, Var, ExprBuilder, LinExpr]) -> LinExpr: ...
    @overload
    def __rsub__(self, other: QuadExpr) -> QuadExpr: ...
    @overload
    def __rsub__(self, other: PsdExpr) -> PsdExpr: ...
    def __isub__(self, other: Union[float, Var, ExprBuilder, LinExpr]) -> LinExpr: ...
    @overload
    def __mul__(self, other: float) -> LinExpr: ...
    @overload
    def __mul__(self, other: Union[Var, ExprBuilder, LinExpr]) -> QuadExpr: ...
    @overload
    def __rmul__(self, other: float) -> LinExpr: ...
    @overload
    def __rmul__(self, other: Union[Var, ExprBuilder, LinExpr]) -> QuadExpr: ...
    def __imul__(self, other: float) -> LinExpr: ...
    def __pow__(self, other: int) -> QuadExpr: ...
    def __truediv__(self, other: float) -> LinExpr: ...
    def __itruediv__(self, other: float) -> LinExpr: ...
    def __neg__(self) -> LinExpr: ...
    # '==', '<=' and '>=' are used as constraint sense
    @overload
    def __eq__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __eq__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __eq__(self, other: PsdExpr) -> PsdConstrBuilder: ...
    @overload
    def __le__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __le__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __le__(self, other: PsdExpr) -> PsdConstrBuilder: ...
    @overload
    def __ge__(self, other: _LinExprLike) -> ConstrBuilder: ...
    @overload
    def __ge__(self, other: QuadExpr) -> QConstrBuilder: ...
    @overload
    def __ge__(self, other: PsdExpr) -> PsdConstrBuilder: ...

class QuadExpr:
    # mutable info or params
    constant: float = ...

    @overload
    def __init__(
        self,
        arg1: Union[Var, ExprBuilder, LinExpr],
        arg2: Optional[float] = None
        ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: Union[ExprBuilder, LinExpr],
        arg2: Union[Var, ExprBuilder, LinExpr] = None
        ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: QuadExpr,
        arg2: Optional[float] = None
    ) -> None: ...
    @overload
    def __init__(
        self,
        arg1: float = 0.0
    ) -> None: ...
    def setCoeff(self, idx: int, newval: float) -> None: ...
    def getCoeff(self, idx: int) -> float: ...
    def getVar1(self, idx: int) -> Var: ...
    def getVar2(self, idx: int) -> Var: ...
    def getLinExpr(self) -> LinExpr: ...
    def getConstant(self) -> float: ...
    def getValue(self) -> float: ...
    def getSize(self) -> int: ...
    def setConstant(self, newval: float) -> None: ...
    def addConstant(self, newval: float) -> None: ...
    def addTerm(self, coeff: float, var1: Var, var2: Var = None) -> None: ...
    def addTerms(
        self,
        coeffs: Union[float, Sequence[float]],
        vars1: Union[Var, VarArray, Iterable[Var], Mapping[Any, Var]],
        vars2: Optional[Union[Var, VarArray, Iterable[Var], Mapping[Any, Var]]] = None
        ) -> None: ...
    def addLinExpr(self, expr: Union[ExprBuilder, LinExpr], mult: float = 1.0) -> None: ...
    def addQuadExpr(self, expr: QuadExpr, mult: float = 1.0) -> None: ...
    def clone(self) -> QuadExpr: ...
    def reserve(self, n: int) -> None: ...
    def remove(self, item: Union[int, Var]) -> None: ...

    # read-only info or attributes
    @property
    def value(self) -> float: ...
    @property
    def size(self) -> int: ...

    def __add__(self, other: _QuadExprLike) -> QuadExpr: ...
    def __radd__(self, other: _QuadExprLike) -> QuadExpr: ...
    def __iadd__(self, other: _QuadExprLike) -> QuadExpr: ...
    def __sub__(self, other: _QuadExprLike) -> QuadExpr: ...
    def __rsub__(self, other: _QuadExprLike) -> QuadExpr: ...
    def __isub__(self, other: _QuadExprLike) -> QuadExpr: ...
    def __mul__(self, other: float) -> QuadExpr: ...
    def __rmul__(self, other: float) -> QuadExpr: ...
    def __imul__(self, other: float) -> QuadExpr: ...
    def __truediv__(self, other: float) -> QuadExpr: ...
    def __itruediv__(self, other: float) -> QuadExpr: ...
    def __neg__(self) -> QuadExpr: ...
    # '==', '<=' and '>=' are used as constraint sense
    def __eq__(self, other: _QuadExprLike) -> QConstrBuilder: ...
    def __le__(self, other: _QuadExprLike) -> QConstrBuilder: ...
    def __ge__(self, other: _QuadExprLike) -> QConstrBuilder: ...

class PsdExpr:
    # mutable info or params
    constant: float = ...

    def __init__(
        self,
        expr: _PsdExprLike = 0.0
        ) -> None: ...
    def setCoeff(self, idx: int, mat: SymMatrix) -> None: ...
    def getCoeff(self, idx: int) -> SymMatrix: ...
    def getPsdVar(self, idx: int) -> PsdVar: ...
    def getLinExpr(self) -> LinExpr: ...
    def getConstant(self) -> float: ...
    def getValue(self) -> float: ...
    def getSize(self) -> int: ...
    def setConstant(self, newval: float) -> None: ...
    def addConstant(self, newval: float) -> None: ...
    @overload
    def addTerm(self, var: PsdVar, mat: SymMatrix) -> None: ...
    @overload
    def addTerm(self, var: Var, mat: float) -> None: ...
    def addTerms(
        self,
        vars: Union[Var, VarArray, Iterable[Var], Mapping[Any, Var]],
        mats: Union[SymMatrix, SymMatrixArray, Iterable[SymMatrix], Mapping[Any, SymMatrix]]
        ) -> None: ...
    def addLinExpr(self, expr: Union[ExprBuilder, LinExpr], mult: float = 1.0) -> None: ...
    def addPsdExpr(self, expr: PsdExpr, mult: float = 1.0) -> None: ...
    def clone(self) -> PsdExpr: ...
    def reserve(self, n: int) -> None: ...
    def remove(self, item: Union[int, Var, PsdVar]) -> None: ...

    # read-only info or attributes
    @property
    def value(self) -> float: ...
    @property
    def size(self) -> int: ...

    def __add__(self, other: _PsdExprLike) -> PsdExpr: ...
    def __radd__(self, other: _PsdExprLike) -> PsdExpr: ...
    def __iadd__(self, other: _PsdExprLike) -> PsdExpr: ...
    def __sub__(self, other: _PsdExprLike) -> PsdExpr: ...
    def __rsub__(self, other: _PsdExprLike) -> PsdExpr: ...
    def __isub__(self, other: _PsdExprLike) -> PsdExpr: ...
    def __mul__(self, other: float) -> PsdExpr: ...
    def __rmul__(self, other: float) -> PsdExpr: ...
    def __imul__(self, other: float) -> PsdExpr: ...
    def __truediv__(self, other: float) -> PsdExpr: ...
    def __itruediv__(self, other: float) -> PsdExpr: ...
    def __neg__(self) -> PsdExpr: ...
    # '==', '<=' and '>=' are used as constraint sense
    def __eq__(self, other: _PsdExprLike) -> PsdConstrBuilder: ...
    def __le__(self, other: _PsdExprLike) -> PsdConstrBuilder: ...
    def __ge__(self, other: _PsdExprLike) -> PsdConstrBuilder: ...
    

class ProbBuffer:
    def __init__(self, buff: int = 0) -> None: ...
    def getData(self) -> str: ...
    def getSize(self) -> int: ...
    def reSize(self, sz: int) -> None: ... 

class EnvrConfig:
    def __init__(self) -> None: ...
    def set(self, name: str, value: str) -> None: ...

class Envr:
    def __init__(
        self,
        arg: Optional[Union[str, EnvrConfig]] = None
        ) -> None: ...
    def createModel(self, name: str = "") -> Model: ...
    def close(self) -> None: ...

class Model:
    # mutable info or params
    # TODO: add more if needed
    objsense: int = ...
    ObjSense: int = ...
    objconst: float = ...
    ObjConst: float = ...

    # read-only info or attributes
    # TODO: add more if needed
    @property
    def cols(self) -> int: ...
    @property
    def Cols(self) -> int: ...
    @property
    def rows(self) -> int: ...
    @property
    def Rows(self) -> int: ...
    @property
    def elems(self) -> int: ...
    @property
    def Elems(self) -> int: ...
    @property
    def bestgap(self) -> float: ...
    @property
    def BestGap(self) -> float: ...
    @property
    def hasbasis(self) -> int: ...
    @property
    def HasBasis(self) -> int: ...
    @property
    def hasFeasRelaxSol(self) -> int: ...
    @property
    def HasFeasRelaxSol(self) -> int: ...
    @property
    def hasIIS(self) -> int: ...
    @property
    def HasIIS(self) -> int: ...
    @property
    def haslpsol(self) -> int: ...
    @property
    def HasLpSol(self) -> int: ...
    @property
    def hasmipsol(self) -> int: ...
    @property
    def HasMipSol(self) -> int: ...
    @property
    def ismip(self) -> int: ...
    @property
    def IsMIP(self) -> int: ...
    @property
    def lpobjval(self) -> float: ...
    @property
    def LpObjVal(self) -> float: ...
    @property
    def objval(self) -> float: ...
    @property
    def ObjVal(self) -> float: ...
    @property
    def lpstatus(self) -> int: ...
    @property
    def LpStatus(self) -> int: ...
    @property
    def PoolSols(self) -> int: ...
    @property
    def status(self) -> int: ...
    @property
    def Status(self) -> int: ...
    @property
    def SimplexIter(self) -> int: ...
    @property
    def SolvingTime(self) -> float: ...
    @property
    def param(self) -> ParamSetting: ...
    @property
    def Param(self) -> ParamSetting: ...

    def addVar(
        self,
        lb: float = 0.0,
        ub: float = COPT.INFINITY,
        obj: float = 0.0,
        vtype: str = COPT.CONTINUOUS,
        name: str = "",
        column: Optional[Column] = None
        ) -> Var: ...

    # single int arg + scalar kwargs
    @overload
    def addVars(
        self,
        __indices: int,
        *,
        lb: float = 0.0,
        ub: float = COPT.INFINITY,
        obj: float = 0.0,
        vtype: str = COPT.CONTINUOUS,
        nameprefix: str = "C"
        ) -> tupledict[int, Var]: ...

    # multiple int args + scalar kwargs
    @overload
    def addVars(
        self,
        __indices1: int,
        __indices2: int,
        *indices: int,
        lb: float = 0.0,
        ub: float = COPT.INFINITY,
        obj: float = 0.0,
        vtype: str = COPT.CONTINUOUS,
        nameprefix: str = "C"
        ) -> tupledict[Tuple[int, ...], Var]: ...

    # single list of scalar or tuple arg + scalar/list kwargs
    @overload
    def addVars(
        self,
        __indices: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        *,
        lb: Union[float, Iterable[float], Iterable[Iterable[float]]] = 0.0,
        ub: Union[float, Iterable[float], Iterable[Iterable[float]]] = COPT.INFINITY,
        obj: Union[float, Iterable[float], Iterable[Iterable[float]]] = 0.0,
        vtype: Union[str, Iterable[str], Iterable[Iterable[str]]] = COPT.CONTINUOUS,
        nameprefix: str = "C"
        ) -> tupledict[Any, Var]: ...

    # single list of scalar or tuple arg + scalar/dict kwargs
    @overload
    def addVars(
        self,
        __indices: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        *,
        lb: Union[float, Mapping[Any, float]] = 0.0,
        ub: Union[float, Mapping[Any, float]] = COPT.INFINITY,
        obj: Union[float, Mapping[Any, float]] = 0.0,
        vtype: Union[str, Mapping[Any, str]] = COPT.CONTINUOUS,
        nameprefix: str = "C"
        ) -> tupledict[Any, Var]: ...

    # multiple list of scalar or tuple args + scalar/list kwargs
    @overload
    def addVars(
        self,
        __indices1: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        __indices2: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        *indices: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        lb: Union[float, Iterable[float], Iterable[Iterable[float]]] = 0.0,
        ub: Union[float, Iterable[float], Iterable[Iterable[float]]] = COPT.INFINITY,
        obj: Union[float, Iterable[float], Iterable[Iterable[float]]] = 0.0,
        vtype: Union[str, Iterable[str], Iterable[Iterable[str]]] = COPT.CONTINUOUS,
        nameprefix: str = "C"
        ) -> tupledict[Tuple[Any, ...], Var]: ...

    # multiple list of scalar or tuple args + scalar/dict kwargs
    @overload
    def addVars(
        self,
        __indices1: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        __indices2: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        *indices: Iterable[Union[_Scalar, Tuple[_Scalar, ...]]],
        lb: Union[float, Mapping[Any, float]] = 0.0,
        ub: Union[float, Mapping[Any, float]] = COPT.INFINITY,
        obj: Union[float, Mapping[Any, float]] = 0.0,
        vtype: Union[str, Mapping[Any, str]] = COPT.CONTINUOUS,
        nameprefix: str = "C"
        ) -> tupledict[Tuple[Any, ...], Var]: ...

    @overload
    def addConstr(
        self,
        lhs: _LinExprLike,
        sense: str,
        rhs: _LinExprLike,
        name: str = ""
        ) -> Constraint: ...
    
    @overload
    def addConstr(
        self,
        lhs: PsdExpr,
        sense: str,
        rhs: _PsdExprLike,
        name: str = ""
        ) -> PsdConstraint: ...
    
    @overload
    def addConstr(
        self,
        lhs: _PsdExprLike,
        sense: str,
        rhs: PsdExpr,
        name: str = ""
        ) -> PsdConstraint: ...
    
    @overload
    def addConstr(self, lhs: bool, name: str = "") -> Constraint: ...
    @overload
    def addConstr(self, lhs: ConstrBuilder, name: str = "") -> Constraint: ...
    @overload
    def addConstr(self, lhs: Tuple[ConstrBuilder, str, float], name: str = "") -> Constraint: ...
    @overload
    def addConstr(self, lhs: GenConstrBuilder, name: str = "") -> GenConstr: ...
    @overload
    def addConstr(self, lhs: PsdConstrBuilder, name: str = "") -> PsdConstraint: ...
    @overload
    def addConstr(self, lhs: Tuple[PsdConstrBuilder, str, float], name: str = "") -> PsdConstraint: ...

    @overload
    def addBoundConstr(
        self,
        expr: _LinExprLike,
        lb: float = -COPT.INFINITY,
        ub: float = COPT.INFINITY,
        name: str = ""
        ) -> Constraint: ...
    @overload
    def addBoundConstr(
        self,
        expr: PsdExpr,
        lb: float = -COPT.INFINITY,
        ub: float = COPT.INFINITY,
        name: str = ""
        ) -> PsdConstraint: ...

    @overload
    def addConstrs(self, generator: bool, nameprefix: str = "R") -> Constraint: ...

    @overload
    def addConstrs(self, generator: int, nameprefix: str = "R") -> ConstrArray: ...

    @overload
    def addConstrs(
        self,
        generator: Iterable[ConstrBuilder],
        nameprefix: str = "R"
    ) -> tupledict[Any, Constraint]: ...

    @overload
    def addConstrs(
        self,
        generator: Generator[ConstrBuilder, None, None],
        nameprefix: str = "R"
    ) -> tupledict[Any, Constraint]: ...

    @overload
    def addSOS(
        self,
        sostype: int, 
        vars: Union[Var, VarArray, Iterable[Var]], 
        weights: Optional[Iterable[float]] = None
        ) -> SOS: ...

    @overload
    def addSOS(
        self,
        sostype: int, 
        vars: Mapping[_T, Var], 
        weights: Optional[Mapping[_T, float]] = None
        ) -> SOS: ...

    @overload
    def addSOS(self, sostype: SOSBuilder, vars: Any=None, weights: Any=None) -> SOS: ...

    @overload
    def addGenConstrIndicator(
        self, 
        binvar: Var, 
        binval: int, 
        lhs: _LinExprLike, 
        sense: str, 
        rhs: float
        ) -> GenConstr: ...

    @overload
    def addGenConstrIndicator(
        self, 
        binvar: Var, 
        binval: int, 
        lhs: ConstrBuilder, 
        ) -> GenConstr: ...

    def addConeByDim(
        self, 
        dim: int, 
        ctype: int, 
        vtype: Optional[Sequence[str]], 
        nameprefix: str = "ConV"
        ) -> Cone: ...

    @overload
    def addCone(
        self, 
        vars: Union[Var, VarArray, Iterable[Var], Mapping[Any, Var]], 
        ctype: int
        ) -> Cone: ...

    @overload
    def addCone(self, vars: ConeBuilder) -> Cone: ...

    @overload
    def addQConstr(
        self,
        lhs: _LinExprLike,
        sense: str,
        rhs: _LinExprLike,
        name: str = ""
        ) -> Constraint: ...
    
    @overload
    def addQConstr(
        self,
        lhs: QuadExpr,
        sense: str,
        rhs: _QuadExprLike,
        name: str = ""
        ) -> QConstraint: ...
    
    @overload
    def addQConstr(
        self,
        lhs: _QuadExprLike,
        sense: str,
        rhs: QuadExpr,
        name: str = ""
        ) -> QConstraint: ...
    
    @overload
    def addQConstr(self, lhs: bool, name: str = "") -> Constraint: ...
    @overload
    def addQConstr(self, lhs: ConstrBuilder, name: str = "") -> Constraint: ...
    @overload
    def addQConstr(self, lhs: Tuple[ConstrBuilder, str, float], name: str = "") -> Constraint: ...
    @overload
    def addQConstr(self, lhs: QConstrBuilder, name: str = "") -> QConstraint: ...
    @overload
    def addQConstr(self, lhs: Tuple[QConstrBuilder, str, float], name: str = "") -> QConstraint: ...

    def addPsdVar(self, dim: int, name: str = "") -> PsdVar: ...

    @overload
    def addPsdVars(self, dims: int, nameprefix: str = "PSDV") -> PsdVar: ...
    @overload
    def addPsdVars(self, dims: Sequence[int], nameprefix: str = "PSDV") -> PsdVarArray: ...

    @overload
    def addSparseMat(
        self, 
        dim: int, 
        rows: Sequence[Tuple[int, int, float]]
        ) -> SymMatrix: ...

    @overload
    def addSparseMat(
        self, 
        dim: int, 
        rows: Sequence[int], 
        cols: Sequence[int], 
        vals: Sequence[float]
        ) -> SymMatrix: ...

    def addDenseMat(
        self, 
        dim: int, 
        vals: Union[float, Sequence[float]]
        ) -> SymMatrix: ...

    def addDiagMat(
        self, 
        dim: int, 
        vals: Union[float, Sequence[float]], 
        offset: int = None
        ) -> SymMatrix: ...

    def addOnesMat(self, dim: int) -> SymMatrix: ...
    def addEyeMat(self, dim: int) -> SymMatrix: ...
    def addSymMat(self, expr: SymMatExpr) -> SymMatrix: ...
    def getSymMat(self, idx: int) -> SymMatrix: ...

    def setObjective(self, expr: Union[_QuadExprLike, PsdExpr], sense: int = None) -> None: ...
    def setObjSense(self, sense: int) -> None: ...
    def setObjConst(self, constant: float) -> None: ...
    def getObjective(self) -> Union[LinExpr, PsdExpr, QuadExpr]: ...

    def delQuadObj(self) -> None: ...
    def delPsdObj(self) -> None: ...

    def getCol(self, var: Var) -> Column: ...
    def getRow(self, constr: Constraint) -> LinExpr: ...
    def getQuadRow(self, qconstr: QConstraint) -> QuadExpr: ...
    def getPsdRow(self, constr: PsdConstraint) -> PsdExpr: ...

    def getVar(self, idx: int) -> Var: ...
    def getVarByName(self, name: str) -> Var: ...
    def getVars(self) -> VarArray: ...

    def getConstr(self, idx: int) -> Constraint: ...
    def getConstrByName(self, name: str) -> Constraint: ...
    def getConstrs(self) -> ConstrArray: ...

    @overload
    def getConstrBuilders(
        self, 
        constrs: Optional[Union[ConstrArray, Sequence[Constraint]]] = None 
        ) -> ConstrBuilderArray: ...

    @overload
    def getConstrBuilders(
        self, 
        constrs: Constraint
        ) -> ConstrBuilder: ...

    @overload
    def getConstrBuilders(
        self, 
        constrs: Mapping[_T, Constraint]
        ) -> tupledict[_T, ConstrBuilder]: ...

    def getSOSs(self) -> SOSArray: ...
    def getSOS(self, sos: SOS) -> SOSBuilder: ...

    @overload
    def getSOSBuilders(self, soss: SOS) -> SOSBuilder: ...

    @overload
    def getSOSBuilders(
        self, 
        soss: Union[Iterable[SOS], Mapping[Any, SOS]] = None
        ) -> SOSBuilderArray: ...

    def getGenConstrIndicator(self, genconstr: GenConstr) -> GenConstrBuilder: ...

    def getCones(self) -> ConeArray: ...

    @overload
    def getConeBuilders(self, cones: Cone) -> ConeBuilder: ...

    @overload
    def getConeBuilders(
        self, 
        cones: Union[Iterable[Cone], Mapping[Any, Cone]] = None
        ) -> ConeBuilderArray: ...
    
    def getQConstr(self, idx: int) -> QConstraint: ...
    def getQConstrByName(self, name: str) -> QConstraint: ...
    def getQConstrs(self) -> QConstrArray: ...

    @overload
    def getQConstrBuilders(self, qconstrs: QConstraint) -> QConstrBuilder: ...

    @overload
    def getQConstrBuilders(
        self, 
        qconstrs: Optional[Union[QConstrArray, Sequence[QConstraint]]] = None 
        ) -> QConstrBuilderArray: ...

    @overload
    def getQConstrBuilders(
        self, 
        qconstrs: Mapping[_T, QConstraint]
        ) -> tupledict[_T, QConstrBuilder]: ...

    def getPsdVar(self, idx: int) -> PsdVar: ...
    def getPsdVarByName(self, name: str) -> PsdVar: ...
    def getPsdVars(self) -> PsdVarArray: ...

    def getPsdConstr(self, idx: int) -> PsdConstraint: ...
    def getPsdConstrByName(self, name: str) -> PsdConstraint: ...
    def getPsdConstrs(self) -> PsdConstrArray: ...

    @overload
    def getPsdConstrBuilders(self, constrs: PsdConstraint) -> PsdConstrBuilder: ...

    @overload
    def getPsdConstrBuilders(
        self, 
        constrs: Optional[Union[PsdConstrArray, Sequence[PsdConstraint]]] = None 
        ) -> PsdConstrBuilderArray: ...

    @overload
    def getPsdConstrBuilders(
        self, 
        constrs: Mapping[_T, PsdConstraint]
        ) -> tupledict[_T, PsdConstrBuilder]: ...

    @overload
    def getCoeff(self, constr: Constraint, var: Var) -> float: ...
    @overload
    def getCoeff(self, constr: PsdConstraint, var: PsdVar) -> SymMatrix: ...
    @overload
    def setCoeff(self, constr: Constraint, var: Var, newval: float) -> None: ...
    @overload
    def setCoeff(self, constr: PsdConstraint, var: PsdVar, newval: SymMatrix) -> None: ...

    def getA(self) -> sparse.csc_matrix: ...

    def loadMatrix(
        self, 
        c: Optional[Sequence[float]], 
        A: sparse.csc_matrix, 
        lhs: Sequence[float], 
        rhs: Sequence[float],  
        lb: Optional[Sequence[float]],
        ub: Optional[Sequence[float]], 
        vtype: Optional[Sequence[str]] = None
        ) -> None: ...

    def loadQ(self, Q: sparse.isspmatrix_coo) -> None: ...

    def loadCone(
        self, 
        ncone: int, 
        types: Optional[Sequence[int]], 
        dims: Optional[Sequence[int]],
        indices: Optional[Sequence[int]]
        ) -> None: ...

    def loadConeMatrix(
        self, 
        c: Optional[Sequence[float]], 
        A: sparse.isspmatrix_csc, 
        b: Optional[Sequence[float]], 
        K: Mapping[str, int], 
        Q: Optional[sparse.isspmatrix_coo] = None, 
        vtype: Sequence[str] = None
        ) -> None: ...

    def getLpSolution(self) -> Tuple[List[float], List[float], List[float], List[float]]: ...
    def setLpSolution(
        self,
        values: Sequence[float],
        slack: Sequence[float],
        duals: Sequence[float],
        redcost: Sequence[float]
        ) -> None: ...
    def getPsdSolution(self) -> Tuple[List[float], List[float], List[float], List[float]]: ...
    def getValues(self) -> List[float]: ...
    def getRedcosts(self) -> List[float]: ...
    def getSlacks(self) -> List[float]: ...
    def getDuals(self) -> List[float]: ...
    def getPsdValues(self) -> List[float]: ...
    def getPsdRedcosts(self) -> List[float]: ...
    def getPsdSlacks(self) -> List[float]: ...
    def getPsdDuals(self) -> List[float]: ...

    @overload
    def getVarBasis(self, vars: Var) -> int: ...
    @overload
    def getVarBasis(self, vars: Optional[Sequence[Var]] = None) -> List[int]: ...
    @overload
    def getVarBasis(self, vars: Mapping[_T, Var]) -> tupledict[_T, int]: ...

    @overload
    def getConstrBasis(self, constrs: Constraint) -> int: ...
    @overload
    def getConstrBasis(self, constrs: Optional[Sequence[Constraint]] = None) -> List[int]: ...
    @overload
    def getConstrBasis(self, constrs: Mapping[_T, Constraint]) -> tupledict[_T, int]: ...

    def getPoolObjVal(self, isol: int) -> float: ...

    @overload
    def getPoolSolution(self, isol: int, vars: Var) -> float: ...
    @overload
    def getPoolSolution(self, isol: int, vars: Union[VarArray, Iterable[Var]]) -> List[float]: ...
    @overload
    def getPoolSolution(self, isol: int, vars: Mapping[_T, Var]) -> tupledict[_T, float]: ...

    @overload
    def getVarLowerIIS(self, vars: Var) -> int: ...
    @overload
    def getVarLowerIIS(self, vars: Union[VarArray, Iterable[Var]]) -> List[int]: ...
    @overload
    def getVarLowerIIS(self, vars: Mapping[_T, Var]) -> tupledict[_T, int]: ...

    @overload
    def getVarUpperIIS(self, vars: Var) -> int: ...
    @overload
    def getVarUpperIIS(self, vars: Union[VarArray, Iterable[Var]]) -> List[int]: ...
    @overload
    def getVarUpperIIS(self, vars: Mapping[_T, Var]) -> tupledict[_T, int]: ...

    @overload
    def getConstrLowerIIS(self, constrs: Constraint) -> int: ...
    @overload
    def getConstrLowerIIS(self, constrs: Union[ConstrArray, Iterable[Constraint]]) -> List[int]: ...
    @overload
    def getConstrLowerIIS(self, constrs: Mapping[_T, Constraint]) -> tupledict[_T, int]: ...

    @overload
    def getConstrUpperIIS(self, constrs: Constraint) -> int: ...
    @overload
    def getConstrUpperIIS(self, constrs: Union[ConstrArray, Iterable[Constraint]]) -> List[int]: ...
    @overload
    def getConstrUpperIIS(self, constrs: Mapping[_T, Constraint]) -> tupledict[_T, int]: ...

    @overload
    def getSOSIIS(self, soss: SOS) -> int: ...
    @overload
    def getSOSIIS(self, soss: Union[SOSArray, Iterable[SOS]]) -> List[int]: ...
    @overload
    def getSOSIIS(self, soss: Mapping[_T, SOS]) -> tupledict[_T, int]: ...

    @overload
    def getIndicatorIIS(self, genconstrs: GenConstr) -> int: ...
    @overload
    def getIndicatorIIS(self, genconstrs: Union[GenConstrArray, Iterable[GenConstr]]) -> List[int]: ...
    @overload
    def getIndicatorIIS(self, genconstrs: Mapping[_T, GenConstr]) -> tupledict[_T, int]: ...

    def getAttr(self, attrname: str) -> Union[int, float]: ...

    @overload
    def getInfo(self, infoname: str, args: Union[Var, Constraint, PsdConstraint, QConstraint]) -> float: ...
    @overload
    def getInfo(self, infoname: str, args: Iterable[Union[Var, Constraint, PsdConstraint, QConstraint]]) -> List[float]: ...
    @overload
    def getInfo(self, infoname: str, args: Mapping[_T, Union[Var, Constraint, PsdConstraint, QConstraint]]) -> tupledict[_T, float]: ...

    @overload
    def getVarType(self, vars: Var) -> str: ...
    @overload
    def getVarType(self, vars: Union[VarArray, Iterable[Var]]) -> List[str]: ...
    @overload
    def getVarType(self, vars: Mapping[_T, Var]) -> tupledict[_T, str]: ...

    def getParam(self, paramname: str) -> Union[int, float]: ...
    def getParamInfo(
        self, 
        paramname: str
        ) -> Union[Tuple[str, int, int, int, int], Tuple[str, float, float, float, float]]: ...

    def setBasis(self, varbasis: Sequence[int], constrbasis: Sequence[int]) -> None: ...
    def setSlackBasis(self) -> None: ...

    @overload
    def setVarType(self, vars: Var, vartypes: str) -> None: ...
    @overload
    def setVarType(
        self,
        vars: Union[VarArray, Iterable[Var]], 
        vartypes: Union[str, Sequence[str]]
        ) -> None: ...
    @overload
    def setVarType(
        self, 
        vars: Mapping[_T, Var], 
        vartypes: Union[str, Mapping[_T, str]]
        ) -> None: ...

    @overload
    def setMipStart(self, vars: Var, startvals: float) -> None: ...
    @overload
    def setMipStart(
        self, 
        vars: Union[VarArray, Iterable[Var]], 
        startvals: Union[float, Sequence[float]]
        ) -> None: ...
    @overload
    def setMipStart(
        self, 
        vars: Mapping[_T, Var], 
        startvals: Union[float, Mapping[_T, float]]
        ) -> None: ...

    def loadMipStart(self) -> None: ...

    @overload
    def setInfo(
        self, 
        infoname: str, 
        args: Union[Var, Constraint, PsdConstraint], 
        newvals: float
        ) -> None: ...
    @overload
    def setInfo(
        self, 
        infoname: str, 
        args: Iterable[Union[Var, Constraint, PsdConstraint]],
        newvals: Union[float, Sequence[float]]
        ) -> None: ...
    @overload
    def setInfo(
        self, 
        infoname: str, 
        args: Mapping[_T, Union[Var, Constraint, PsdConstraint]],
        newvals: Union[float, Mapping[_T, float]]
        ) -> None: ...

    def setParam(self, paramname: str, newval: Union[int, float]) -> None: ...
    def resetParam(self) -> None: ...

    def read(self, filename: str) -> None: ...
    def readMps(self, filename: str) -> None: ...
    def readLp(self, filename: str) -> None: ...
    def readSdpa(self, filename: str) -> None: ...
    def readCbf(self, filename: str) -> None: ...
    def readBin(self, filename: str) -> None: ...
    def readSol(self, filename: str) -> None: ...
    def readBasis(self, filename: str) -> None: ...
    def readMst(self, filename: str) -> None: ...
    def readParam(self, filename: str) -> None: ...
    def readTune(self, filename: str) -> None: ...

    def write(self, filename: str) -> None: ...
    def writeMps(self, filename: str) -> None: ...
    def writeMpsStr(self) -> ProbBuffer: ...
    def writeLp(self, filename: str) -> None: ...
    def writeCbf(self, filename: str) -> None: ...
    def writeBin(self, filename: str) -> None: ...
    def writeIIS(self, filename: str) -> None: ...
    def writeRelax(self, filename: str) -> None: ...
    def writeSol(self, filename: str) -> None: ...
    def writePoolSol(self, isol: int, filename: str) -> None: ...
    def writeBasis(self, filename: str) -> None: ...
    def writeMst(self, filename: str) -> None: ...
    def writeParam(self, filename: str) -> None: ...
    def writeTuneParam(self, idx: int, filename: str) -> None: ...

    def setLogFile(self, logfile: str) -> None: ...
    def setLogCallback(self, logcb: Any) -> None: ...

    def solve(self) -> None: ...
    def solveLP(self) -> None: ...
    def computeIIS(self) -> None: ...

    @overload
    def feasRelax(
        self, 
        vars: Union[Var, VarArray, Iterable[Var]],
        lbpen: Union[float, Iterable[float]], 
        ubpen: Union[float, Iterable[float]], 
        constrs: Union[Constraint, ConstrArray, Iterable[Constraint]], 
        rhspen: Union[float, Iterable[float]], 
        uppen: Optional[Union[float, Iterable[float]]] = None
        ) -> None: ...

    @overload
    def feasRelax(
        self, 
        vars: Mapping[Any, Var], 
        lbpen: Mapping[Any, float], 
        ubpen: Mapping[Any, float], 
        constrs: Mapping[Any, Constraint], 
        rhspen: Mapping[Any, float], 
        uppen: Optional[Mapping[Any, float]] = None
        ) -> None: ...

    def feasRelaxS(self, vrelax:int , crelax: int) -> None: ...

    def tune(self) -> None: ...
    def loadTuenParam(self, idx: int) -> None: ...

    def interrupt(self) -> None: ...
    def remove(
        self, 
        args: Union[_ModelComponent, Iterable[_ModelComponent], Mapping[Any, _ModelComponent]]
        ) -> None: ...

    def resetAll(self) -> None: ...
    def reset(self) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> Model: ...

class tupledict(Dict[_T, _U]):
    def clean(self) -> None: ...
    def keys(self) -> tuplelist[_T]: ...
    def values(self) -> List[_U]: ...
    def prod(
        self,
        coeff: Mapping[Any, float],
        *pattern: Union[_Scalar, Sequence[_Scalar]]
        ) -> float if isinstance(_U, float) else LinExpr: ...
    def select(self, *pattern: Union[_Scalar, Sequence[_Scalar]]) -> List[_U]: ...
    def sum(
        self, 
        *pattern: Union[_Scalar, Sequence[_Scalar]]
        ) -> float if isinstance(_U, float) else LinExpr: ...

class tuplelist(List[_T]):
    def clean(self) -> None: ...
    def select(self, *pattern: Union[_Scalar, Sequence[_Scalar]]) -> List[_T]: ...
    def add(self, key: Iterable[_U]) -> None: ...
    def append(self, key: Iterable[_U]) -> None: ...
