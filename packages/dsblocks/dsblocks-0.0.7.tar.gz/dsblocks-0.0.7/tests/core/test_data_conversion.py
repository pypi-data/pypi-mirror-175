# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/00_tests/core/tst.data_conversion.ipynb.

# %% auto 0
__all__ = ['generate_input_for_window_generator', 'test_data_converter_functions', 'test_no_converter', 'test_generic_converter',
           'test_may_have_y', 'test_standard_converter', 'test_pandas_converter', 'test_window2d_to_3d_converter',
           'test_data_converter_factory']

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 2
from dsblocks.core.data_conversion import *

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 3
import pytest 
import numpy as np
import os
import joblib
from IPython.display import display
import pandas as pd

from dsblocks.core.components import Component
from dsblocks.utils.utils import remove_previous_results
import dsblocks.config.bt_defaults as dflt
from dsblocks.blocks.preprocessing import WindowGenerator

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 4
def generate_input_for_window_generator ():
    index = pd.period_range (start='2022-01-14', end='2022-01-18', freq='H')
    df = pd.DataFrame (index=index.to_timestamp (), columns=['a','b','label'])
    df.index.name = 'timestamp'
    df['a'] = 10
    df['b'] = 20
    df['label'] = 0
    df.loc[('2022-01-15' <= index) & (index < '2022-01-16'),'label'] = 1
    df.loc[('2022-01-15' <= index) & (index < '2022-01-16'),'a'] = 11
    df.loc[('2022-01-15' <= index) & (index < '2022-01-16'),'b'] = 21
    return df

# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 5
def test_data_converter_functions ():
    X, y = np.array([[1,2,3]]), np.array([0,1,0])
    
    dc = DataConverter (convert_before=lambda x, y: (x.ravel(), y),
                        convert_after=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr, yr = dc.convert_before_transforming (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']
    
    Xr = dc.convert_after_transforming (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']
    
    dc = DataConverter (convert_before_fitting=lambda x, y: (x.ravel(), y),
                        convert_after_fitting=lambda x: {'train':x},
                        convert_before_transforming=lambda x: x.tolist(),
                        convert_after_transforming=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert (Xr['train']==X).all() and Xr['train'].shape==(1,3) and list(Xr.keys())==['train']
    
    Xr = dc.convert_before_transforming (X)
    assert (Xr==X.tolist()) and type(Xr) is list
    
    Xr = dc.convert_after_transforming (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']
    
    dc = DataConverter (convert_before_fitting=lambda x, y: (x.ravel(), y),
                        convert_after_transforming=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert Xr == (X,)
    
    Xr = dc.convert_before_transforming (X)
    assert Xr == (X,)
    
    Xr = dc.convert_after_transforming (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 6
def test_no_converter ():
    dc = NoConverter()
    X, y = [1,2,3], [0,1,0]
    Xr, yr = dc.convert_before_fitting (X, y)
    assert X==Xr
    assert y==yr
    
    # We can pass conversion functions to the NoConverter class. 
    # In that case, the NoConverter behaves as the base class DataConverter
    X, y = np.array([[1,2,3]]), np.array([0,1,0])
    dc = NoConverter (convert_before_fitting=lambda x, y: (x.ravel(), y),
                        convert_after_transforming=lambda x: {'test':x})
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X.ravel()).all() and Xr.shape==(3,)
    assert (yr==y).all()
    
    Xr = dc.convert_after_fitting (X)
    assert Xr == (X,)
    
    Xr = dc.convert_before_transforming (X)
    assert Xr == (X,)
    
    Xr = dc.convert_after_transforming (X)
    assert (Xr['test']==X).all() and Xr['test'].shape==(1,3) and list(Xr.keys())==['test']


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 7
def test_generic_converter ():
    dc = GenericConverter()
    
    def transform_returns_labels_singleX (X, y):
        return X, y
    
    def transform_returns_labels_twoXs (a, b, y):
        return a, b, y
    
    def transform_does_not_return_labels_singleX (X):
        return X
    
    def transform_does_not_return_labels_twoXs (a, b):
        return a, b
    
    def transform_does_not_return_labels_singleX_and_y (X, y):
        return X
    
    def transform_does_not_return_labels_twoXs_and_y (a, b, y):
        return a, b
    
    def fit_apply (*X, y=None, result_func=None, dc=None):
        X = dc.convert_single_tuple (X)
        X = X + (y, ) if y is not None else X
        # fit (*X) fit does nothing
        # apply
        return apply (*X, result_func=result_func, dc=dc, fit_apply=True)
    
    def apply (*X, result_func=None, dc=None, fit_apply=False):
        X = dc.convert_single_tuple (X)
        X = dc.convert_before_transforming (*X, fit_apply=fit_apply)
        result = result_func (*X)
        result = dc.convert_after_transforming (result)
        return result
    
    result = fit_apply ([10], y=[1], result_func=transform_does_not_return_labels_singleX, dc=dc)
    assert result==[10]
    result = fit_apply ([10], [1], result_func=transform_does_not_return_labels_singleX, dc=dc)
    assert result==[10]
    
    result = fit_apply ([10], [20], y=[1], result_func=transform_does_not_return_labels_twoXs, dc=dc)
    assert result == ([10],[20])
    result = fit_apply ([10], [20], [1], result_func=transform_does_not_return_labels_twoXs, dc=dc)
    assert result == ([10],[20])
    result = fit_apply (result, y=[1], result_func=transform_does_not_return_labels_twoXs, dc=dc)
    assert result == ([10],[20])
    
    with pytest.raises (TypeError):
        result = fit_apply ([10],  y=[1], result_func=transform_returns_labels_singleX, dc=dc)
    
    dc = GenericConverter (transform_uses_labels=True)
    result = fit_apply ([10],  y=[1], result_func=transform_returns_labels_singleX, dc=dc)
    assert result==([10],[1])
    result = fit_apply ([10], [1], result_func=transform_returns_labels_singleX, dc=dc)
    assert result==([10],[1])
    result = fit_apply (result, result_func=transform_returns_labels_singleX, dc=dc)
    assert result==([10],[1])
    
    result = fit_apply ([10], y=[1], result_func=transform_does_not_return_labels_singleX_and_y, dc=dc)
    assert result==([10],[1])
    result = fit_apply ([10], [1], result_func=transform_does_not_return_labels_singleX_and_y, dc=dc)
    assert result==([10],[1])
    result = fit_apply (result, result_func=transform_does_not_return_labels_singleX_and_y, dc=dc)
    assert result==([10],[1])
    
    result = fit_apply ([10], [20], y=[1], result_func=transform_returns_labels_twoXs, dc=dc)
    assert result==([10], [20], [1])
    result = fit_apply ([10], [20], [1], result_func=transform_returns_labels_twoXs, dc=dc)
    assert result==([10], [20], [1])
    result = fit_apply (result, result_func=transform_returns_labels_twoXs, dc=dc)
    assert result==([10], [20], [1])
    
    dc = GenericConverter (transform_uses_labels=True, labels_returned_by_transform=False)
    result = fit_apply ([10], [20], y=[1], result_func=transform_does_not_return_labels_twoXs_and_y, dc=dc)
    assert result == ([10], [20], [1])
    result = fit_apply ([10], [20], [1], result_func=transform_does_not_return_labels_twoXs_and_y, dc=dc)
    assert result == ([10], [20], [1])
    result = fit_apply (result, result_func=transform_does_not_return_labels_twoXs_and_y, dc=dc)
    assert result == ([10], [20], [1])
    
    dc = GenericConverter (raise_error_if_no_label_inconsistency=True)
    with pytest.raises (TypeError):
        result = fit_apply ([10], result_func=transform_does_not_return_labels_singleX, dc=dc)
    with pytest.raises (TypeError):
        result = fit_apply ([10], [20], result_func=transform_does_not_return_labels_twoXs, dc=dc)
    
    dc = GenericConverter ()
    result = fit_apply ([10], result_func=transform_does_not_return_labels_singleX, dc=dc)
    assert result==[10]
    with pytest.raises (TypeError):
        result = fit_apply ([10], [20], result_func=transform_does_not_return_labels_twoXs, dc=dc)
    
    dc = GenericConverter (no_labels=True)
    result = fit_apply ([10], result_func=transform_does_not_return_labels_singleX, dc=dc)
    assert result==[10]
    result = fit_apply ([10], [20], result_func=transform_does_not_return_labels_twoXs, dc=dc)
    assert result == ([10], [20])
    result = fit_apply (result, result_func=transform_does_not_return_labels_twoXs, dc=dc)
    assert result == ([10], [20])


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 8
def test_may_have_y ():
    data_converter = GenericConverter ()
    assert data_converter._may_have_y (
                 ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), [1,2,4,5])
                 )
    
    assert data_converter._may_have_y (
                 ('yes', np.array ([[2,1,3],[3,4,5]]), [1,2])
                 )
    
    assert not data_converter._may_have_y (
                ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), [1,2,4,5,6])
                )
    
    assert not data_converter._may_have_y (
                 ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), [1,2,4])
                 )
    
    assert not data_converter._may_have_y (
                ([1,2,3,4], np.array ([[2,1,3],[3,4,5]]), 3)
                )
                 
    assert not data_converter._may_have_y (
                 ('yes', 'no', [1,2])
                 )


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 9
def test_standard_converter ():
    X, y = np.array([[1,2,3]]), np.array([0,1,0])
    
    dc = StandardConverter ()
    
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    assert (yr==y).all()
    
    Xr, yr = dc.convert_before_transforming (X, y)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    assert (yr==y).all()
    
    Xr = dc.convert_before_transforming (X, y, fit_apply=True)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    
    Xr, yr = dc.convert_after_transforming (X, sequential_fit_apply=True)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    assert (yr==y).all()
    
    Xr = dc.convert_before_transforming (X, y, fit_apply=True)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    
    Xr = dc.convert_after_transforming (X)
    assert (Xr==X).all().all() and Xr.shape==(1, 3)
    
    Xr, yr = dc.convert_before_transforming ((X,X*2), y)
    assert type(Xr) is tuple and len(Xr)==2
    assert (Xr[0]==X).all().all() and Xr[0].shape==(1, 3)
    assert (Xr[1]==X*2).all().all() and Xr[1].shape==(1, 3)
    assert (yr==y).all()
    
    Xr = dc.convert_before_transforming ((X,X*2), y, fit_apply=True)
    assert type(Xr) is tuple and len(Xr)==2
    assert (Xr[0]==X).all().all() and Xr[0].shape==(1, 3)
    assert (Xr[1]==X*2).all().all() and Xr[1].shape==(1, 3)
    
    Xr, yr = dc.convert_after_transforming ((X, X*2), sequential_fit_apply=True)
    assert type(Xr) is tuple and len(Xr)==2
    assert (Xr[0]==X).all().all() and Xr[0].shape==(1, 3)
    assert (yr==y).all()    


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 10
def test_pandas_converter ():
    dc = PandasConverter()
    
    # First case: if the input is a DataFrame, the output is a DataFrame, 
    # even when the transformer outputs a numpy array
    dc = PandasConverter()
    X, y = pd.DataFrame({'a':[1,2,3],'b':[4,5,6]}), np.array([0,1,0])
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (X==Xr).all().all() and (y==yr).all() and type(Xr)==type(X) and type(yr)==type(y)
    Xr = dc.convert_before_transforming (X)
    assert (X==Xr).all().all() and type(Xr)==type(X)
    Xo = dc.convert_after_transforming (Xr.values)
    assert (X==Xo).all().all() and type(Xo)==type(X)
    
    # Second case: the transformer outputs a DataFrame
    Xo = dc.convert_after_transforming (Xr)
    assert (X==Xo).all().all()
    
    # Third case: if the input is a numpy array, the output is a numpy array, 
    # when the transformer outputs a numpy array
    X, y = np.array([[1,2,3],[4,5,6]]), np.array([0,1,0])
    Xr, yr = dc.convert_before_fitting (X, y)
    assert (X==Xr).all().all() and (y==yr).all() and type(Xr)==type(X) and type(yr)==type(y)
    Xr = dc.convert_before_transforming (X)
    assert (X==Xr).all().all() and type(Xr)==type(X)
    Xo = dc.convert_after_transforming (Xr)
    assert (X==Xo).all().all() and type(Xo)==type(X)
    
    # Fourth case: if the transformer outputs a DataFrame, the output is 
    # a DataFrame, even if the input was a numpy array. 
    # TODO: we might want to have the possibility to output a numpy 
    # array in this case.
    Xo = dc.convert_after_transforming (pd.DataFrame(Xr))
    assert (X==Xo).all().all() and type(Xo)==pd.DataFrame


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 11
def test_window2d_to_3d_converter ():
    df = generate_input_for_window_generator ()
    window_generator = WindowGenerator(sequence_length=3, sequence_stride=1, sampling_interval=60)
    window_data = window_generator.transform(df)
    assert window_data.shape==(91, 7)
    
    dc = Window2Dto3Dconverter (sequence_length=3)
    dfr = dc.convert_before_transforming(window_data)
    assert dfr.shape==(91, 3, 2)
    
    window_datar = dc.convert_after_transforming(dfr)
    #print (window_datar.shape)
    assert window_datar.shape==(91, 7)
    
    dfr2,y = dc.convert_before_fitting (window_data)
    assert dfr2.shape==(91, 3, 2) and y.shape==(91,)
    
    aux = dc.convert_after_fitting (dfr2)[0]
    assert aux.shape==(91, 3, 2)
    
    assert (np.unique(dfr.sum(axis=1))==[30,33,60,63]).all()
    assert (np.where(dfr.sum(axis=1)[:,0]==33)[0]==range(22,44)).all()
    assert (np.where(dfr.sum(axis=1)[:,1]==63)[0]==range(22,44)).all()


# %% ../../../nbs/00_tests/core/tst.data_conversion.ipynb 12
def test_data_converter_factory ():
    converter = data_converter_factory ('PandasConverter', separate_labels=False)
    assert type(converter) is PandasConverter
    assert converter.separate_labels is False

